[
  {
    "id": "questdb-community_hn-0eb14e8952e8",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=23975807",
    "title": "Launch HN: QuestDB (YC S20) – Fast open source time series database",
    "text": "# Launch HN: QuestDB (YC S20) – Fast open source time series database\n\nHN Discussion: https://news.ycombinator.com/item?id=23975807\n\n## Top Comments\n\n**maz1b**: Hi Vlad, this looks really interesting! I really enjoyed reading the backstory and the founding dynamics upon QuestDB was born and I think a lot of others in the YC community will as well. Can you give some use cases or specific examples of why QuestDB is unique?\n\n---\n\n**js4ever**: https:&#x2F;&#x2F;try.questdb.io:9000&#x2F;  is down\n\n---\n\n**aloukissas**: This is great! Quick question: would you mind sharing why you went with Java vs something perhaps more performant like all C&#x2F;C++ or Rust? I&#x27;d suspect language familiarity (which is 100% ok).\n\n---\n\n**zumachase**: Hi Vlad - your anecdote about ship tracking is interesting (my other startup is an AIS based dry freight trader). You must know the Vortexa guys given your BP background. How does QuestDB differ from other timeseries&#x2F;OLAP offerings? I&#x27;m not entirely clear.\n\n---\n\n**jedberg**: How does your performance compare to Atlas? [0] [0]  https:&#x2F;&#x2F;github.com&#x2F;Netflix&#x2F;atlas",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "positive",
    "word_count": 163,
    "metadata": {
      "hn_id": 23975807,
      "points": 357,
      "num_comments": 167,
      "author": "bluestreak",
      "created_at": "2020-07-28T13:57:12Z",
      "top_comments": [
        "**maz1b**: Hi Vlad, this looks really interesting! I really enjoyed reading the backstory and the founding dynamics upon QuestDB was born and I think a lot of others in the YC community will as well. Can you give some use cases or specific examples of why QuestDB is unique?",
        "**js4ever**: https:&#x2F;&#x2F;try.questdb.io:9000&#x2F;  is down",
        "**aloukissas**: This is great! Quick question: would you mind sharing why you went with Java vs something perhaps more performant like all C&#x2F;C++ or Rust? I&#x27;d suspect language familiarity (which is 100% ok).",
        "**zumachase**: Hi Vlad - your anecdote about ship tracking is interesting (my other startup is an AIS based dry freight trader). You must know the Vortexa guys given your BP background. How does QuestDB differ from other timeseries&#x2F;OLAP offerings? I&#x27;m not entirely clear.",
        "**jedberg**: How does your performance compare to Atlas? [0] [0]  https:&#x2F;&#x2F;github.com&#x2F;Netflix&#x2F;atlas"
      ]
    }
  },
  {
    "id": "questdb-community_hn-c128d80f25af",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=31767858",
    "title": "No, QuestDB is not Faster than ClickHouse",
    "text": "# No, QuestDB is not Faster than ClickHouse\n\nHN Discussion: https://news.ycombinator.com/item?id=31767858\nOriginal URL: https://telegra.ph/No-QuestDB-is-not-Faster-than-ClickHouse-06-15\n\n## Top Comments\n\n**thegeomaster**: Sounds like they didn&#x27;t re-do the QuestDB benchmark with same change to the indexes, and so their claim is that Clickhouse is 27x faster with a specific index than QuestDB without that index. Which is not a fair comparison. Also, the tone of the post sounds really arrogant. They try to hide it a bit, I feel, but it just seeps through.\n\n---\n\n**PeterZaitsev**: This response illustrates important point - if you&#x27;re expert in technology A and compare it to technology B, you&#x27;re not expert in, comparison is  very likely to be unfair. I very much would like to see vendors at least to follow Journalist ethics and reach out to their competition for optimization comments and suggestions before publishing it, so others are given a chance to suggest optimizations\n\n---\n\n**noxvilleza**: Is there an existing named adage for something like &quot;if one creates a benchmark in order to rank general performance of some products, some of those products will ultimately sacrifice general performance in order to optimize for that benchmark&quot;?\n\n---\n\n**bluestreak**: Our article in question can be found here:  https:&#x2F;&#x2F;questdb.io&#x2F;blog&#x2F;2022&#x2F;05&#x2F;26&#x2F;query-benchmark-questdb-v...  The intent of the article was to showcase JIT-optimised WHERE clause and we did not use any indexes on QuestDB.\n\n---\n\n**gauravphoenix**: I have always felt that DB benchmarks are useless, always use your own dataset  https:&#x2F;&#x2F;gauravkumar.blog&#x2F;performance-benchmarks-are-useless....",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 237,
    "metadata": {
      "hn_id": 31767858,
      "points": 144,
      "num_comments": 63,
      "author": "krnaveen14",
      "created_at": "2022-06-16T16:21:49Z",
      "top_comments": [
        "**thegeomaster**: Sounds like they didn&#x27;t re-do the QuestDB benchmark with same change to the indexes, and so their claim is that Clickhouse is 27x faster with a specific index than QuestDB without that index. Which is not a fair comparison. Also, the tone of the post sounds really arrogant. They try to hide it a bit, I feel, but it just seeps through.",
        "**PeterZaitsev**: This response illustrates important point - if you&#x27;re expert in technology A and compare it to technology B, you&#x27;re not expert in, comparison is  very likely to be unfair. I very much would like to see vendors at least to follow Journalist ethics and reach out to their competition for optimization comments and suggestions before publishing it, so others are given a chance to suggest optimizations",
        "**noxvilleza**: Is there an existing named adage for something like &quot;if one creates a benchmark in order to rank general performance of some products, some of those products will ultimately sacrifice general performance in order to optimize for that benchmark&quot;?",
        "**bluestreak**: Our article in question can be found here:  https:&#x2F;&#x2F;questdb.io&#x2F;blog&#x2F;2022&#x2F;05&#x2F;26&#x2F;query-benchmark-questdb-v...  The intent of the article was to showcase JIT-optimised WHERE clause and we did not use any indexes on QuestDB.",
        "**gauravphoenix**: I have always felt that DB benchmarks are useless, always use your own dataset  https:&#x2F;&#x2F;gauravkumar.blog&#x2F;performance-benchmarks-are-useless...."
      ]
    }
  },
  {
    "id": "questdb-community_hn-23c7595089fc",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=34883046",
    "title": "Show HN: QuestDB with Python, Pandas and SQL in a Jupyter notebook – no install",
    "text": "# Show HN: QuestDB with Python, Pandas and SQL in a Jupyter notebook – no install\n\nHN Discussion: https://news.ycombinator.com/item?id=34883046\nOriginal URL: https://play.questdb.io/\n\n## Top Comments\n\n**amunra__**: Hi, I&#x27;m Adam Cimarosti, one of the core engineers at QuestDB. We built play.questdb.io to make it easy for anyone to try our database.\nNo installation. There&#x27;s a Jupyter Lab notebook, data, sample code, queries and graphs. We&#x27;d love to hear what you think.",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 70,
    "metadata": {
      "hn_id": 34883046,
      "points": 53,
      "num_comments": 15,
      "author": "bluestreak",
      "created_at": "2023-02-21T16:30:54Z",
      "top_comments": [
        "**amunra__**: Hi, I&#x27;m Adam Cimarosti, one of the core engineers at QuestDB. We built play.questdb.io to make it easy for anyone to try our database.\nNo installation. There&#x27;s a Jupyter Lab notebook, data, sample code, queries and graphs. We&#x27;d love to hear what you think."
      ]
    }
  },
  {
    "id": "questdb-community_hn-138a64b7badc",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=33209584",
    "title": "Io_uring Prototype for QuestDB",
    "text": "# Io_uring Prototype for QuestDB\n\nHN Discussion: https://news.ycombinator.com/item?id=33209584\nOriginal URL: https://github.com/questdb/questdb/pull/2298",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 11,
    "metadata": {
      "hn_id": 33209584,
      "points": 31,
      "num_comments": 0,
      "author": "mfiguiere",
      "created_at": "2022-10-14T22:32:33Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-a3d66b4e8cdf",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=23427047",
    "title": "IoT on QuestDB",
    "text": "# IoT on QuestDB\n\nHN Discussion: https://news.ycombinator.com/item?id=23427047\nOriginal URL: https://davidgs.com/2020/iot-on-questdb/\n\n## Top Comments\n\n**bogdanu**: Why am I redirected to porn?!\n\n---\n\n**fasteo**: Did not know about QuestDB “QuestDB is an open source database which makes time-series fast and easy.”\n\n---\n\n**ryanmjacobs**: Huh, didn&#x27;t know about QuestDB either. Looks super interesting. I use PostgreSQL + Metabase for my time series IoT stuff, lots of temperature sensors. This almost looks faster  and  easier. Will look into it. Thanks for sharing!\n\n---\n\n**frhack**: Very interesting, but can anyone explain the underlying technology?\nThere are no free lunches.\nHere we have sql join on time series data. Very cool, but is it really sustainable?\n\n---\n\n**sgt**: I had not heard of QuestDB. We are considering moving our InfluxDB databases to PostgreSQL with Timescale. Is QuestDB something we should consider before making the switch? Perhaps more importantly, is it stable?",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 145,
    "metadata": {
      "hn_id": 23427047,
      "points": 28,
      "num_comments": 22,
      "author": "bluestreak",
      "created_at": "2020-06-05T10:38:02Z",
      "top_comments": [
        "**bogdanu**: Why am I redirected to porn?!",
        "**fasteo**: Did not know about QuestDB “QuestDB is an open source database which makes time-series fast and easy.”",
        "**ryanmjacobs**: Huh, didn&#x27;t know about QuestDB either. Looks super interesting. I use PostgreSQL + Metabase for my time series IoT stuff, lots of temperature sensors. This almost looks faster  and  easier. Will look into it. Thanks for sharing!",
        "**frhack**: Very interesting, but can anyone explain the underlying technology?\nThere are no free lunches.\nHere we have sql join on time series data. Very cool, but is it really sustainable?",
        "**sgt**: I had not heard of QuestDB. We are considering moving our InfluxDB databases to PostgreSQL with Timescale. Is QuestDB something we should consider before making the switch? Perhaps more importantly, is it stable?"
      ]
    }
  },
  {
    "id": "questdb-community_hn-c0842194472a",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=21666790",
    "title": "Show HN: QuestDB – fast time series database, zero-GC Java",
    "text": "# Show HN: QuestDB – fast time series database, zero-GC Java\n\nHN Discussion: https://news.ycombinator.com/item?id=21666790\nOriginal URL: https://www.questdb.io/\n\n## Top Comments\n\n**bluestreak**: Back in 2012, my former boss forced me to use marklogic as a database to ingest and help display positional data in real-time. Unable to get marklogic to work without building fairly complex caches around it, I then decided to look around for a database, which would have performance properties of a cache. With none found (I missed redis somehow) and no money to spend on KDB, I started to cobble together file based storage and cache to work as a cohesive unit. Let me tell you, I learnt a lot more in that one year than my prior 15 years developing software. Addicted to learning new things, I doubled-down on turning the storage+cache idea into a functioning database, without realising how hard it was to turn this idea into reality. Unwilling to give up, and fast forwarding to almost 2020, I&#x27;m asking you to provide feedback about what I&#x27;ve accomplished so far. QuestDB is currently usable as a single node or embedded, whilst not yet supporting horizontal scalability (on our roadmap in 2020&#x27;). Thank you for your time, I look forward to hearing your honest feedback.\n\n---\n\n**dang**: Url changed from  https:&#x2F;&#x2F;github.com&#x2F;questdb&#x2F;questdb  to the project site.\n\n---\n\n**sirffuzzylogik**: How does it compare to kdb performance wise?\n\n---\n\n**priezz**: I understand, that the choice was made 5 years ago, but why Java?\n\n---\n\n**m3slo**: How does it compare to existing time series databases such as InfluxDB, Prometheus or even Graphite?",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 261,
    "metadata": {
      "hn_id": 21666790,
      "points": 22,
      "num_comments": 10,
      "author": "bluestreak",
      "created_at": "2019-11-29T21:03:32Z",
      "top_comments": [
        "**bluestreak**: Back in 2012, my former boss forced me to use marklogic as a database to ingest and help display positional data in real-time. Unable to get marklogic to work without building fairly complex caches around it, I then decided to look around for a database, which would have performance properties of a cache. With none found (I missed redis somehow) and no money to spend on KDB, I started to cobble together file based storage and cache to work as a cohesive unit. Let me tell you, I learnt a lot more in that one year than my prior 15 years developing software. Addicted to learning new things, I doubled-down on turning the storage+cache idea into a functioning database, without realising how hard it was to turn this idea into reality. Unwilling to give up, and fast forwarding to almost 2020, I&#x27;m asking you to provide feedback about what I&#x27;ve accomplished so far. QuestDB is currently usable as a single node or embedded, whilst not yet supporting horizontal scalability (on our roadmap in 2020&#x27;). Thank you for your time, I look forward to hearing your honest feedback.",
        "**dang**: Url changed from  https:&#x2F;&#x2F;github.com&#x2F;questdb&#x2F;questdb  to the project site.",
        "**sirffuzzylogik**: How does it compare to kdb performance wise?",
        "**priezz**: I understand, that the choice was made 5 years ago, but why Java?",
        "**m3slo**: How does it compare to existing time series databases such as InfluxDB, Prometheus or even Graphite?"
      ]
    }
  },
  {
    "id": "questdb-community_hn-59e9f84328c6",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=31585563",
    "title": "4Bn rows/sec query benchmark: ClickHouse vs. QuestDB vs. Timescale",
    "text": "# 4Bn rows/sec query benchmark: ClickHouse vs. QuestDB vs. Timescale\n\nHN Discussion: https://news.ycombinator.com/item?id=31585563\nOriginal URL: https://questdb.io/blog/2022/05/26/query-benchmark-questdb-versus-clickhouse-timescale/\n\n## Top Comments\n\n**bluestreak**: Last year we released QuestDB 6.0 and achieved an ingestion rate of 1.4 million rows per second (per server). We compared those results to popular open source databases [1] and explained how we dealt with out of order ingestion under the hood while keeping the underlying storage model read-friendly. Since then, we focused our efforts on making queries faster, in particular filter queries with WHERE clauses. To do so, we once again decided to make things from scratch and built a JIT (Just-in-Time) compiler for SQL filters, with tons of low-level optimisations such as SIMD. We then parallelized the query execution to  improve the execution time even further. In this blog post, we first look at some benchmarks against Clickhouse and TimescaleDB, before digging deeper in how this all works within QuestDB&#x27;s storage model. Once again, we use the Time Series Benchmark Suite (TSBS) [2], developed by TimescaleDB,: it is an open source and reproducible benchmark. We&#x27;d love to get your feedback! [1]: https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27411307  [2]: https:&#x2F;&#x2F;github.com&#x2F;timescale&#x2F;tsbs\n\n---\n\n**ericb**: It is definitely useful to be able to consume a lot of data quickly, especially high-cardinality data. Inevitably, an infinite flood of data will eventually consume any finite space limitations. I&#x27;m wondering what QuestDB&#x27;s story for data aggregation and cleanup looks like?\n\n---\n\n**ysleepy**: This looks cool, I&#x27;ve been looking at time series DBs lately and mostly landed with timescale because of the ability to have complete freedom querying the dataset with postgres kitchen sink. The post here really focuses on one query and that is weirdly without a time sort.\nWould similar queries be also fast? - What about a join, aggregates, lag()-over, subqueries, unions, etc queries\n\n---\n\n**nojvek**: Very cool blog post. Looks similar to SingleStore, I wonder how it would perform on the same benchmark. They also use JIT and scan parallelization.\n\n---\n\n**untitaker_**: This table schema:  https:&#x2F;&#x2F;github.com&#x2F;timescale&#x2F;tsbs&#x2F;blob&#x2F;bcc00137d72d889e6059e...  ...seems like a quite odd way to store time-series in ClickHouse. If I understood that code correctly (and I am really not sure), they partition their data by some tag value (the first one in a list?), and sort each partition by &quot;tags ID&quot;, while timescaledb partitions by time afaik. Of course there will be large discrepancies if data is sorted one way in one database schema, and another way in another schema. It seems that at least their query of &quot;ORDER BY time LIMIT 10&quot; would greatly benefit from partitioning or sorting the table by time. Whether that makes sense depends on your usecase. But I don&#x27;t think a benchmark with completely dfferent schemas, partitioning and primary keys across databases is fair. Another thing I noticed is that their version of ClickHouse is quite old, at least aroudn the time the test was written. The shown CREATE TABLE syntax is deprecated since a few versions and cannot be found in recent docs, only github:  https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;blob&#x2F;v18.16&#x2F;docs&#x2F;en...",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "mixed",
    "word_count": 495,
    "metadata": {
      "hn_id": 31585563,
      "points": 20,
      "num_comments": 15,
      "author": "bluestreak",
      "created_at": "2022-06-01T17:56:16Z",
      "top_comments": [
        "**bluestreak**: Last year we released QuestDB 6.0 and achieved an ingestion rate of 1.4 million rows per second (per server). We compared those results to popular open source databases [1] and explained how we dealt with out of order ingestion under the hood while keeping the underlying storage model read-friendly. Since then, we focused our efforts on making queries faster, in particular filter queries with WHERE clauses. To do so, we once again decided to make things from scratch and built a JIT (Just-in-Time) compiler for SQL filters, with tons of low-level optimisations such as SIMD. We then parallelized the query execution to  improve the execution time even further. In this blog post, we first look at some benchmarks against Clickhouse and TimescaleDB, before digging deeper in how this all works within QuestDB&#x27;s storage model. Once again, we use the Time Series Benchmark Suite (TSBS) [2], developed by TimescaleDB,: it is an open source and reproducible benchmark. We&#x27;d love to get your feedback! [1]: https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27411307  [2]: https:&#x2F;&#x2F;github.com&#x2F;timescale&#x2F;tsbs",
        "**ericb**: It is definitely useful to be able to consume a lot of data quickly, especially high-cardinality data. Inevitably, an infinite flood of data will eventually consume any finite space limitations. I&#x27;m wondering what QuestDB&#x27;s story for data aggregation and cleanup looks like?",
        "**ysleepy**: This looks cool, I&#x27;ve been looking at time series DBs lately and mostly landed with timescale because of the ability to have complete freedom querying the dataset with postgres kitchen sink. The post here really focuses on one query and that is weirdly without a time sort.\nWould similar queries be also fast? - What about a join, aggregates, lag()-over, subqueries, unions, etc queries",
        "**nojvek**: Very cool blog post. Looks similar to SingleStore, I wonder how it would perform on the same benchmark. They also use JIT and scan parallelization.",
        "**untitaker_**: This table schema:  https:&#x2F;&#x2F;github.com&#x2F;timescale&#x2F;tsbs&#x2F;blob&#x2F;bcc00137d72d889e6059e...  ...seems like a quite odd way to store time-series in ClickHouse. If I understood that code correctly (and I am really not sure), they partition their data by some tag value (the first one in a list?), and sort each partition by &quot;tags ID&quot;, while timescaledb partitions by time afaik. Of course there will be large discrepancies if data is sorted one way in one database schema, and another way in another schema. It seems that at least their query of &quot;ORDER BY time LIMIT 10&quot; would greatly benefit from partitioning or sorting the table by time. Whether that makes sense depends on your usecase. But I don&#x27;t think a benchmark with completely dfferent schemas, partitioning and primary keys across databases is fair. Another thing I noticed is that their version of ClickHouse is quite old, at least aroudn the time the test was written. The shown CREATE TABLE syntax is deprecated since a few versions and cannot be found in recent docs, only github:  https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;blob&#x2F;v18.16&#x2F;docs&#x2F;en..."
      ]
    }
  },
  {
    "id": "questdb-community_hn-6b384312a9e2",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=30114066",
    "title": "We Built a SIMD JIT Compiler for SQL in QuestDB",
    "text": "# We Built a SIMD JIT Compiler for SQL in QuestDB\n\nHN Discussion: https://news.ycombinator.com/item?id=30114066\nOriginal URL: https://questdb.io/blog/2022/01/12/jit-sql-compiler/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 17,
    "metadata": {
      "hn_id": 30114066,
      "points": 16,
      "num_comments": 0,
      "author": "bluestreak",
      "created_at": "2022-01-28T13:06:07Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-32a281e94c09",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=21655945",
    "title": "QuestDB – Fast open source relational time series database",
    "text": "# QuestDB – Fast open source relational time series database\n\nHN Discussion: https://news.ycombinator.com/item?id=21655945\nOriginal URL: https://www.questdb.io/\n\n## Top Comments\n\n**bluestreak**: Hi, QuestDB&#x27;s author here, thanks for posting! I wanted to post this on Show HN, but someone beat me to it! We are an open source (Apache 2.0) time-series database, programmed in zero-GC Java. You can find us on GitHub  https:&#x2F;&#x2F;github.com&#x2F;questdb&#x2F;questdb . We would like to get your feedback.",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 69,
    "metadata": {
      "hn_id": 21655945,
      "points": 14,
      "num_comments": 2,
      "author": "beagle3",
      "created_at": "2019-11-28T09:57:03Z",
      "top_comments": [
        "**bluestreak**: Hi, QuestDB&#x27;s author here, thanks for posting! I wanted to post this on Show HN, but someone beat me to it! We are an open source (Apache 2.0) time-series database, programmed in zero-GC Java. You can find us on GitHub  https:&#x2F;&#x2F;github.com&#x2F;questdb&#x2F;questdb . We would like to get your feedback."
      ]
    }
  },
  {
    "id": "questdb-community_hn-51e4bfdef833",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=31759798",
    "title": "No, QuestDB is not Faster than ClickHouse",
    "text": "# No, QuestDB is not Faster than ClickHouse\n\nHN Discussion: https://news.ycombinator.com/item?id=31759798\nOriginal URL: https://telegra.ph/No-QuestDB-is-not-Faster-than-ClickHouse-06-15",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 14,
    "metadata": {
      "hn_id": 31759798,
      "points": 14,
      "num_comments": 0,
      "author": "untitaker_",
      "created_at": "2022-06-15T21:39:18Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-a04250294e84",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=31095298",
    "title": "CMU Database Tech Talks: QuestDB [video]",
    "text": "# CMU Database Tech Talks: QuestDB [video]\n\nHN Discussion: https://news.ycombinator.com/item?id=31095298\nOriginal URL: https://www.youtube.com/watch?v=AxxutZ0v3HE",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 13,
    "metadata": {
      "hn_id": 31095298,
      "points": 6,
      "num_comments": 0,
      "author": "nhourcard",
      "created_at": "2022-04-20T11:24:01Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-a8e78b089ef5",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=23167494",
    "title": "QuestDB 4.2.1 Release. SIMD performance gain 20%. Clickhouse benchmark",
    "text": "# QuestDB 4.2.1 Release. SIMD performance gain 20%. Clickhouse benchmark\n\nHN Discussion: https://news.ycombinator.com/item?id=23167494\nOriginal URL: https://github.com/questdb/questdb/releases/tag/4.2.1",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 16,
    "metadata": {
      "hn_id": 23167494,
      "points": 6,
      "num_comments": 0,
      "author": "bluestreak",
      "created_at": "2020-05-13T14:58:17Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-81b5a2cd71d3",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=45954022",
    "title": "Benchmarking KDB-X vs. QuestDB, ClickHouse, TimescaleDB and InfluxDB",
    "text": "# Benchmarking KDB-X vs. QuestDB, ClickHouse, TimescaleDB and InfluxDB\n\nHN Discussion: https://news.ycombinator.com/item?id=45954022\nOriginal URL: https://kx.com/blog/benchmarking-kdb-x-vs-questdb-clickhouse-timescaledb-and-influxdb-with-tsbs/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 15,
    "metadata": {
      "hn_id": 45954022,
      "points": 5,
      "num_comments": 0,
      "author": "rustc",
      "created_at": "2025-11-17T14:45:40Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-926858b3c49b",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=33774415",
    "title": "QuestDB 6.6 – Dynamic Commits",
    "text": "# QuestDB 6.6 – Dynamic Commits\n\nHN Discussion: https://news.ycombinator.com/item?id=33774415\nOriginal URL: https://questdb.io/blog/2022/11/25/questdb-6.6.1-dynamic-commits/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 12,
    "metadata": {
      "hn_id": 33774415,
      "points": 5,
      "num_comments": 0,
      "author": "advaitruia",
      "created_at": "2022-11-28T14:59:59Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-7fc9704fe2e2",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=21836138",
    "title": "QuestDB adds Influx Line Protocol to ingest time-series data, (much) faster",
    "text": "# QuestDB adds Influx Line Protocol to ingest time-series data, (much) faster\n\nHN Discussion: https://news.ycombinator.com/item?id=21836138\nOriginal URL: https://medium.com/@tancrede.collard/questdb-adds-influx-line-protocol-to-ingest-time-series-data-much-faster-361d0671cfcb",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 18,
    "metadata": {
      "hn_id": 21836138,
      "points": 5,
      "num_comments": 0,
      "author": "bluestreak",
      "created_at": "2019-12-19T16:10:20Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-5ea3eb117888",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=41408752",
    "title": "QuestDB is an open source time-series database for fast ingest and SQL queries",
    "text": "# QuestDB is an open source time-series database for fast ingest and SQL queries\n\nHN Discussion: https://news.ycombinator.com/item?id=41408752\nOriginal URL: https://github.com/questdb/questdb",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 20,
    "metadata": {
      "hn_id": 41408752,
      "points": 4,
      "num_comments": 0,
      "author": "tosh",
      "created_at": "2024-08-31T13:31:11Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-46a55bf2026e",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=34016546",
    "title": "Using Prometheus, Loki, and Grafana to Monitor QuestDB in Kubernetes",
    "text": "# Using Prometheus, Loki, and Grafana to Monitor QuestDB in Kubernetes\n\nHN Discussion: https://news.ycombinator.com/item?id=34016546\nOriginal URL: https://questdb.io/blog/2022/12/13/using-prometheus-loki-grafana-monitor-questdb-kubernetes/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 17,
    "metadata": {
      "hn_id": 34016546,
      "points": 4,
      "num_comments": 0,
      "author": "Ramiro",
      "created_at": "2022-12-16T16:33:43Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-8828aa259594",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=12048871",
    "title": "QuestDB – OpenSource Time Series Database",
    "text": "# QuestDB – OpenSource Time Series Database\n\nHN Discussion: https://news.ycombinator.com/item?id=12048871",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 10,
    "metadata": {
      "hn_id": 12048871,
      "points": 3,
      "num_comments": 2,
      "author": "bluestreak",
      "created_at": "2016-07-07T12:30:07Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-81cf3285c081",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=37578424",
    "title": "FoundationDB vs. QuestDB vs. SurrealDB Comparison",
    "text": "# FoundationDB vs. QuestDB vs. SurrealDB Comparison\n\nHN Discussion: https://news.ycombinator.com/item?id=37578424\nOriginal URL: https://db-engines.com/en/system/FoundationDB%3BQuestDB%3BSurrealDB",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 13,
    "metadata": {
      "hn_id": 37578424,
      "points": 3,
      "num_comments": 0,
      "author": "gorenb",
      "created_at": "2023-09-19T23:20:13Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-c957d5a4efe9",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=31170429",
    "title": "Time Series Data Analytics with QuestDB and Cube",
    "text": "# Time Series Data Analytics with QuestDB and Cube\n\nHN Discussion: https://news.ycombinator.com/item?id=31170429\nOriginal URL: https://cube.dev/blog/time-series-data-analytics-with-questdb",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 15,
    "metadata": {
      "hn_id": 31170429,
      "points": 3,
      "num_comments": 0,
      "author": "igorlukanin",
      "created_at": "2022-04-26T17:30:34Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-782b16622381",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=29474029",
    "title": "A tour of high-frequency finance via the Julia language and QuestDB",
    "text": "# A tour of high-frequency finance via the Julia language and QuestDB\n\nHN Discussion: https://news.ycombinator.com/item?id=29474029\nOriginal URL: https://questdb.io/tutorial/2021/11/22/high-frequency-finance-introduction-julia-lang/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 18,
    "metadata": {
      "hn_id": 29474029,
      "points": 3,
      "num_comments": 0,
      "author": "dm13450",
      "created_at": "2021-12-07T16:04:45Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-bd5c2584360a",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=27843217",
    "title": "Interview with Vlad of QuestDB: “the problem was that I didn’t own a computer”",
    "text": "# Interview with Vlad of QuestDB: “the problem was that I didn’t own a computer”\n\nHN Discussion: https://news.ycombinator.com/item?id=27843217\nOriginal URL: https://console.dev/interviews/questdb-vlad-ilyushchenko/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 21,
    "metadata": {
      "hn_id": 27843217,
      "points": 3,
      "num_comments": 0,
      "author": "ricklamers",
      "created_at": "2021-07-15T10:27:35Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-e081fb2d9a95",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=27774755",
    "title": "7 years to build a database and get into YC – QuestDB",
    "text": "# 7 years to build a database and get into YC – QuestDB\n\nHN Discussion: https://news.ycombinator.com/item?id=27774755\nOriginal URL: https://console.dev/interviews/questdb-vlad-ilyushchenko/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 19,
    "metadata": {
      "hn_id": 27774755,
      "points": 3,
      "num_comments": 0,
      "author": "dmytton",
      "created_at": "2021-07-08T16:59:57Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-47fcc9dcd9b5",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=33777557",
    "title": "QuestDB adds dynamic commits to optimise data freshness even at high throughput",
    "text": "# QuestDB adds dynamic commits to optimise data freshness even at high throughput\n\nHN Discussion: https://news.ycombinator.com/item?id=33777557\nOriginal URL: https://questdb.io/blog/2022/11/25/questdb-6.6.1-dynamic-commits/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 19,
    "metadata": {
      "hn_id": 33777557,
      "points": 2,
      "num_comments": 1,
      "author": "supercoco9",
      "created_at": "2022-11-28T18:35:10Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-a7c94c32c6d2",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=46336734",
    "title": "Benchmarking Kdb+, ClickHouse, QuestDB, TimescaleDB, and InfluxDB with TSBS",
    "text": "# Benchmarking Kdb+, ClickHouse, QuestDB, TimescaleDB, and InfluxDB with TSBS\n\nHN Discussion: https://news.ycombinator.com/item?id=46336734\nOriginal URL: https://kx.com/blog/benchmarking-kdb-x-vs-questdb-clickhouse-timescaledb-and-influxdb-with-tsbs/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 16,
    "metadata": {
      "hn_id": 46336734,
      "points": 2,
      "num_comments": 0,
      "author": "bk146",
      "created_at": "2025-12-20T15:11:40Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-eac709a25ebc",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=44596054",
    "title": "Don't Get Stale: Fine-Tuning ASOF Join with Tolerance in QuestDB",
    "text": "# Don't Get Stale: Fine-Tuning ASOF Join with Tolerance in QuestDB\n\nHN Discussion: https://news.ycombinator.com/item?id=44596054\nOriginal URL: https://questdb.com/blog/asof-join-tolerance/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 17,
    "metadata": {
      "hn_id": 44596054,
      "points": 2,
      "num_comments": 0,
      "author": "j1897",
      "created_at": "2025-07-17T17:48:24Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-a927319d8a55",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=34452985",
    "title": "Using QuestDB to collect infrastructure metrics",
    "text": "# Using QuestDB to collect infrastructure metrics\n\nHN Discussion: https://news.ycombinator.com/item?id=34452985\nOriginal URL: https://questdb.io/blog/questdb-cloud-metrics-kubernetes/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 13,
    "metadata": {
      "hn_id": 34452985,
      "points": 2,
      "num_comments": 0,
      "author": "EntICOnc",
      "created_at": "2023-01-20T13:42:28Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-06b255dc0ab4",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=30165458",
    "title": "We Built a SIMD JIT Compiler for SQL in QuestDB",
    "text": "# We Built a SIMD JIT Compiler for SQL in QuestDB\n\nHN Discussion: https://news.ycombinator.com/item?id=30165458\nOriginal URL: https://questdb.io/blog/2022/01/12/jit-sql-compiler/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 17,
    "metadata": {
      "hn_id": 30165458,
      "points": 2,
      "num_comments": 0,
      "author": "eatonphil",
      "created_at": "2022-02-01T16:57:42Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-d3db60e842b8",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=29146016",
    "title": "QuestDB",
    "text": "# QuestDB\n\nHN Discussion: https://news.ycombinator.com/item?id=29146016\nOriginal URL: https://github.com/questdb/questdb",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 8,
    "metadata": {
      "hn_id": 29146016,
      "points": 2,
      "num_comments": 0,
      "author": "eddieweng",
      "created_at": "2021-11-08T03:57:03Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-4189d2f4a098",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=28523287",
    "title": "QuestDB 6.0.5 introduces geospatial support",
    "text": "# QuestDB 6.0.5 introduces geospatial support\n\nHN Discussion: https://news.ycombinator.com/item?id=28523287\nOriginal URL: https://questdb.io/blog/2021/09/13/release-6-0-5",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 12,
    "metadata": {
      "hn_id": 28523287,
      "points": 2,
      "num_comments": 0,
      "author": "nhourcard",
      "created_at": "2021-09-14T11:51:40Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-c300ad1a1f37",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=24648455",
    "title": "Checking Out Quest DB",
    "text": "# Checking Out Quest DB\n\nHN Discussion: https://news.ycombinator.com/item?id=24648455\nOriginal URL: https://www.turtle-techies.com/checking-out-quest-db/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 11,
    "metadata": {
      "hn_id": 24648455,
      "points": 2,
      "num_comments": 0,
      "author": "asafg6",
      "created_at": "2020-10-01T07:47:42Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-ed538190ae57",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=11609926",
    "title": "QuestDB – A disk-persisted lightweight embedded edn-based nosql for clojure",
    "text": "# QuestDB – A disk-persisted lightweight embedded edn-based nosql for clojure\n\nHN Discussion: https://news.ycombinator.com/item?id=11609926\nOriginal URL: https://github.com/zeniuseducation/questdb",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 17,
    "metadata": {
      "hn_id": 11609926,
      "points": 2,
      "num_comments": 0,
      "author": "0x54MUR41",
      "created_at": "2016-05-02T08:18:43Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-dfb7594a0458",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=35081307",
    "title": "Inserting 1.8M Rows/s from Pandas into QuestDB with Arrow, Rust and Cython",
    "text": "# Inserting 1.8M Rows/s from Pandas into QuestDB with Arrow, Rust and Cython\n\nHN Discussion: https://news.ycombinator.com/item?id=35081307\nOriginal URL: https://github.com/questdb/py-tsbs-benchmark/blob/main/README.md",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 19,
    "metadata": {
      "hn_id": 35081307,
      "points": 1,
      "num_comments": 1,
      "author": "amunra__",
      "created_at": "2023-03-09T14:11:03Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-8e0d2314cd94",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=24366642",
    "title": "Why we changed our approach to memory mapping at QuestDB (YC S20)",
    "text": "# Why we changed our approach to memory mapping at QuestDB (YC S20)\n\nHN Discussion: https://news.ycombinator.com/item?id=24366642\nOriginal URL: https://questdb.io/blog/2020/08/19/memory-mapping-deep-dive",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 19,
    "metadata": {
      "hn_id": 24366642,
      "points": 1,
      "num_comments": 1,
      "author": "bluestreak",
      "created_at": "2020-09-03T17:52:35Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-f3591112c4d8",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=46634910",
    "title": "Benchmarking KDB-X vs. QuestDB, ClickHouse, TimescaleDB and InfluxDB with TSBS",
    "text": "# Benchmarking KDB-X vs. QuestDB, ClickHouse, TimescaleDB and InfluxDB with TSBS\n\nHN Discussion: https://news.ycombinator.com/item?id=46634910\nOriginal URL: https://kx.com/blog/benchmarking-kdb-x-vs-questdb-clickhouse-timescaledb-and-influxdb-with-tsbs/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 17,
    "metadata": {
      "hn_id": 46634910,
      "points": 1,
      "num_comments": 0,
      "author": "refset",
      "created_at": "2026-01-15T16:23:24Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-b8329edb54e6",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=45325813",
    "title": "Notes on QuestDB's Design: Architecture and Internals",
    "text": "# Notes on QuestDB's Design: Architecture and Internals\n\nHN Discussion: https://news.ycombinator.com/item?id=45325813\nOriginal URL: https://ankitsultana.com/2025/09/12/questdb-braindump.html",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 14,
    "metadata": {
      "hn_id": 45325813,
      "points": 1,
      "num_comments": 0,
      "author": "ankitsultana",
      "created_at": "2025-09-21T19:22:56Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-69c6b80045a4",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=44900005",
    "title": "Show HN: AI Agent Host – Dev Environment with QuestDB, Grafana, and Code-Server",
    "text": "# Show HN: AI Agent Host – Dev Environment with QuestDB, Grafana, and Code-Server\n\nHN Discussion: https://news.ycombinator.com/item?id=44900005\nOriginal URL: https://github.com/quantiota/AI-Agent-Host/tree/main/claude-code",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 20,
    "metadata": {
      "hn_id": 44900005,
      "points": 1,
      "num_comments": 0,
      "author": "quantiota",
      "created_at": "2025-08-14T13:14:57Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-a18571c8b621",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=41235196",
    "title": "A cloud engineer's first QuestDB Pull Request",
    "text": "# A cloud engineer's first QuestDB Pull Request\n\nHN Discussion: https://news.ycombinator.com/item?id=41235196\nOriginal URL: https://questdb.io/blog/my-first-questdb-pull-request/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 14,
    "metadata": {
      "hn_id": 41235196,
      "points": 1,
      "num_comments": 0,
      "author": "sklarsa",
      "created_at": "2024-08-13T13:21:18Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-cc5507d26fa0",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=34443325",
    "title": "Using QuestDB to collect infrastructure metrics",
    "text": "# Using QuestDB to collect infrastructure metrics\n\nHN Discussion: https://news.ycombinator.com/item?id=34443325\nOriginal URL: https://questdb.io/blog/questdb-cloud-metrics-kubernetes/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 13,
    "metadata": {
      "hn_id": 34443325,
      "points": 1,
      "num_comments": 0,
      "author": "sklarsa",
      "created_at": "2023-01-19T17:56:42Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-11c90864fcf1",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=31837298",
    "title": "How we built a SIMD JIT compiler for SQL in QuestDB",
    "text": "# How we built a SIMD JIT compiler for SQL in QuestDB\n\nHN Discussion: https://news.ycombinator.com/item?id=31837298\nOriginal URL: https://questdb.io/blog/2022/01/12/jit-sql-compiler/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 18,
    "metadata": {
      "hn_id": 31837298,
      "points": 1,
      "num_comments": 0,
      "author": "cheeseblubber",
      "created_at": "2022-06-22T15:26:54Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-9dcffd29d754",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=29098388",
    "title": "QuestDB snares $12M Series A with hosted version coming soon",
    "text": "# QuestDB snares $12M Series A with hosted version coming soon\n\nHN Discussion: https://news.ycombinator.com/item?id=29098388\nOriginal URL: https://techcrunch.com/2021/11/03/questdb-snares-12m-series-a-with-hosted-version-on-the-horizon/",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 17,
    "metadata": {
      "hn_id": 29098388,
      "points": 1,
      "num_comments": 0,
      "author": "bluestreak",
      "created_at": "2021-11-03T18:16:19Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-ac07bb0fc59d",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=26012808",
    "title": "QuestDB 5.0.6 released with improvements for PostgreSQL wire protocol",
    "text": "# QuestDB 5.0.6 released with improvements for PostgreSQL wire protocol\n\nHN Discussion: https://news.ycombinator.com/item?id=26012808\nOriginal URL: https://twitter.com/QuestDb/status/1356932224659173380",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 16,
    "metadata": {
      "hn_id": 26012808,
      "points": 1,
      "num_comments": 0,
      "author": "dnsmichi",
      "created_at": "2021-02-03T11:52:53Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-a504a2b006cf",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=12292112",
    "title": "Help us choose a logo for QuestDB",
    "text": "# Help us choose a logo for QuestDB\n\nHN Discussion: https://news.ycombinator.com/item?id=12292112\nOriginal URL: https://99designs.co.uk/contests/poll/ybpmu2?urlcategory=social-media-pack",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 14,
    "metadata": {
      "hn_id": 12292112,
      "points": 1,
      "num_comments": 0,
      "author": "bluestreak",
      "created_at": "2016-08-15T17:54:23Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-0d0476f2d692",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=39306749",
    "title": "Show HN: Open-source template for end-to-end streaming analytics",
    "text": "# Show HN: Open-source template for end-to-end streaming analytics\n\nHN Discussion: https://news.ycombinator.com/item?id=39306749\nOriginal URL: https://github.com/questdb/time-series-streaming-analytics-template\n\n## Top Comments\n\n**supercoco9**: By the way, I presented this repository at the FOSDEM conference just a few days ago. If you want to have more context about what it does, or see a walk-though of the different components, the video is available at  https:&#x2F;&#x2F;fosdem.org&#x2F;2024&#x2F;schedule&#x2F;event&#x2F;fosdem-2024-2871-inge...",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 60,
    "metadata": {
      "hn_id": 39306749,
      "points": 17,
      "num_comments": 1,
      "author": "supercoco9",
      "created_at": "2024-02-08T19:52:55Z",
      "top_comments": [
        "**supercoco9**: By the way, I presented this repository at the FOSDEM conference just a few days ago. If you want to have more context about what it does, or see a walk-though of the different components, the video is available at  https:&#x2F;&#x2F;fosdem.org&#x2F;2024&#x2F;schedule&#x2F;event&#x2F;fosdem-2024-2871-inge..."
      ]
    }
  },
  {
    "id": "questdb-community_hn-ce2854c3a498",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=32172509",
    "title": "Ask HN: Where to Go from Here?",
    "text": "# Ask HN: Where to Go from Here?\n\nHN Discussion: https://news.ycombinator.com/item?id=32172509\n\n## Top Comments\n\n**tmaly**: Financial companies need to consume large amounts of data from external sources. In some cases there is a low-latency requirement.  In all cases there is a reliably requirement. Pay at certain firms in this industry can meet or exceed FAANG\n\n---\n\n**joshxyz**: - maybe other db featured in cmu database group? - maybe transition to finance where low latency stuff meets math problems?\n\n---\n\n**badpun**: Maybe try companies which do systems programming in Java, such as companies behind Elasticsearch, Apache Spark, Apache Cassandra etc. They&#x27;re not doing low-latency work per se, but performance is definitely important for them.",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 113,
    "metadata": {
      "hn_id": 32172509,
      "points": 6,
      "num_comments": 6,
      "author": "abadger9",
      "created_at": "2022-07-20T21:21:53Z",
      "top_comments": [
        "**tmaly**: Financial companies need to consume large amounts of data from external sources. In some cases there is a low-latency requirement.  In all cases there is a reliably requirement. Pay at certain firms in this industry can meet or exceed FAANG",
        "**joshxyz**: - maybe other db featured in cmu database group? - maybe transition to finance where low latency stuff meets math problems?",
        "**badpun**: Maybe try companies which do systems programming in Java, such as companies behind Elasticsearch, Apache Spark, Apache Cassandra etc. They&#x27;re not doing low-latency work per se, but performance is definitely important for them."
      ]
    }
  },
  {
    "id": "questdb-community_hn-4d8a53d9cb48",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=37595536",
    "title": "Ask HN: What does the db business model look like?",
    "text": "# Ask HN: What does the db business model look like?\n\nHN Discussion: https://news.ycombinator.com/item?id=37595536",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 14,
    "metadata": {
      "hn_id": 37595536,
      "points": 4,
      "num_comments": 2,
      "author": "ilikerashers",
      "created_at": "2023-09-21T10:06:06Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-86b548453d7d",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=37786228",
    "title": "Ask HN: How to contribute to open source data stores?",
    "text": "# Ask HN: How to contribute to open source data stores?\n\nHN Discussion: https://news.ycombinator.com/item?id=37786228",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 14,
    "metadata": {
      "hn_id": 37786228,
      "points": 3,
      "num_comments": 2,
      "author": "whynot-123",
      "created_at": "2023-10-06T01:21:31Z",
      "top_comments": []
    }
  },
  {
    "id": "questdb-community_hn-f365799df5de",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=46609630",
    "title": "A 40-line fix eliminated a 400x performance gap",
    "text": "# A 40-line fix eliminated a 400x performance gap\n\nHN Discussion: https://news.ycombinator.com/item?id=46609630\nOriginal URL: https://questdb.com/blog/jvm-current-thread-user-time/\n\n## Top Comments\n\n**jerrinot**: Author here. After my last post about kernel bugs, I spent some time looking at how the JVM reports its own thread activity. It turns out that &quot;What is the CPU time of this thread?&quot; is&#x2F;was a much more expensive question than it should be.\n\n---\n\n**ee99ee**: This is such a great writeup\n\n---\n\n**higherhalf**: clock_gettime() goes through vDSO, avoiding a context switch. It shows up on the flamegraph as well.\n\n---\n\n**ot**: You can do even faster, about 8ns (almost an additional 10x improvement) by using software perf events: PERF_COUNT_SW_TASK_CLOCK is thread CPU time, it can be read through a shared page (so no syscall, see perf_event_mmap_page), and then you add the delta since the last context switch with a single rdtsc call within a seqlock. This is not well documented unfortunately, and I&#x27;m not aware of open-source implementations of this. EDIT: Or maybe not, I&#x27;m not sure if PERF_COUNT_SW_TASK_CLOCK allows to select only user time. The kernel can definitely do it, but I don&#x27;t know if the wiring is there. However this definitely works for overall thread CPU time.\n\n---\n\n**goodroot**: The QuestDB team are among the best doing it. Love the people and their software. Great blog Jaromir!",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "positive",
    "word_count": 220,
    "metadata": {
      "hn_id": 46609630,
      "points": 370,
      "num_comments": 78,
      "author": "bluestreak",
      "created_at": "2026-01-13T23:00:36Z",
      "top_comments": [
        "**jerrinot**: Author here. After my last post about kernel bugs, I spent some time looking at how the JVM reports its own thread activity. It turns out that &quot;What is the CPU time of this thread?&quot; is&#x2F;was a much more expensive question than it should be.",
        "**ee99ee**: This is such a great writeup",
        "**higherhalf**: clock_gettime() goes through vDSO, avoiding a context switch. It shows up on the flamegraph as well.",
        "**ot**: You can do even faster, about 8ns (almost an additional 10x improvement) by using software perf events: PERF_COUNT_SW_TASK_CLOCK is thread CPU time, it can be read through a shared page (so no syscall, see perf_event_mmap_page), and then you add the delta since the last context switch with a single rdtsc call within a seqlock. This is not well documented unfortunately, and I&#x27;m not aware of open-source implementations of this. EDIT: Or maybe not, I&#x27;m not sure if PERF_COUNT_SW_TASK_CLOCK allows to select only user time. The kernel can definitely do it, but I don&#x27;t know if the wiring is there. However this definitely works for overall thread CPU time.",
        "**goodroot**: The QuestDB team are among the best doing it. Love the people and their software. Great blog Jaromir!"
      ]
    }
  },
  {
    "id": "questdb-community_hn-e3cb97598130",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=35793660",
    "title": "Investigating Linux phantom disk reads",
    "text": "# Investigating Linux phantom disk reads\n\nHN Discussion: https://news.ycombinator.com/item?id=35793660\nOriginal URL: https://questdb.io/blog/investigating-linux-phantom-disk-reads/\n\n## Top Comments\n\n**sytse**: TLDR; &quot;Ingestion of a high number of column files under memory pressure led to the kernel starting readahead disk read operations, which you wouldn&#x27;t expect from a write-only load. The rest was as simple as using madvise in our code to disable the readahead in table writers.&quot;\n\n---\n\n**pengaru**: Going through mmap for bulk-ingest sucks because the kernel has to fault in the contents to make what&#x27;s in-core reflect what&#x27;s on-disk before your write access to the mapped memory occurs. It&#x27;s basically a read-modify-write pattern even when all you intended to do was write the entire page. When you just use a write call you provide a unit of arbitrary size, and if you&#x27;ve done your homework that size is a multiple of page size and the offset page-aligned.  Then there&#x27;s no need for the kernel to load anything in for the written pages; you&#x27;re providing everything in the single call.  Then you go down the O_DIRECT rabbithole every fast linux database has historically gone down.\n\n---\n\n**davidhyde**: Seems like using memory mapped files for a write-only load is the sub optimal choice. Maybe I’m mistaken but surely using an append-only file handle would be simpler than changing the behaviour of how memory mapped files are cached like they did for their solution?\n\n---\n\n**addisonj**: I am going to write this comment with a large preface: I don&#x27;t think it is ever helpful to be an absolutist. For every best-practice&#x2F;&quot;right way&quot; to do things, there are circumstances when doing it another way makes sense. That can be a ton of reasons for that, be it technical, money&#x2F;time, etc. The best engineering teams aren&#x27;t those that just blindly follow what others say is a best practice but understand the options and make an informed choice. None of the following comment is at all commentary on questDB, as they mention in the article,  many  databases use similar tools. With that said, after reading the first paragraph I immediately searched the article for &quot;mmap&quot; and had a good sense of where the rest of this was going. Put simply, it is just really hard to consider what the OS is going to do in all situations when using mmap. Based on my experience, I would guess that a  ton  of people reading this comment have hit issues that, I would argue, is due to using mmap. (Particularly looking at you prometheus). All things told, this is a pretty innocuous incident of mmap causing problems, but I would encourage any aspiring DB engineers to read  https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;mmap-cidr2022  as it gives a great overview of the range of problems that can occur when using mmap I think some would argue that mmap is &quot;fine&quot; for append only workloads (and is certainly more reasonable compared to a DB with arbitrary updates) but even here, lots of factors like metadata, scaling number of tables, etc will  eventually  bring you to hit some fundamental problems when using mmap. The interesting opportunity in my mind, especially with improvements in async IO (both at FS level and in tools like rust), is to build higher level abstractions that bring the &quot;simplicity&quot; of mmap, but with more purpose-built semantics ideal for databases.\n\n---\n\n**0xbadcafebee**: There are other methods you can use to increase performance under memory pressure, but you&#x27;d end up handling i&#x2F;o directly and maintaining your own index of memory and disk accesses, page-aligned reads&#x2F;writes, etc. It would be easier to just require your users buy more memory, but when there&#x27;s a hack like this available, that seems preferable to implementing your own VMM and disk i&#x2F;o subsystem.",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "mixed",
    "word_count": 613,
    "metadata": {
      "hn_id": 35793660,
      "points": 302,
      "num_comments": 57,
      "author": "kamaraju",
      "created_at": "2023-05-02T20:25:59Z",
      "top_comments": [
        "**sytse**: TLDR; &quot;Ingestion of a high number of column files under memory pressure led to the kernel starting readahead disk read operations, which you wouldn&#x27;t expect from a write-only load. The rest was as simple as using madvise in our code to disable the readahead in table writers.&quot;",
        "**pengaru**: Going through mmap for bulk-ingest sucks because the kernel has to fault in the contents to make what&#x27;s in-core reflect what&#x27;s on-disk before your write access to the mapped memory occurs. It&#x27;s basically a read-modify-write pattern even when all you intended to do was write the entire page. When you just use a write call you provide a unit of arbitrary size, and if you&#x27;ve done your homework that size is a multiple of page size and the offset page-aligned.  Then there&#x27;s no need for the kernel to load anything in for the written pages; you&#x27;re providing everything in the single call.  Then you go down the O_DIRECT rabbithole every fast linux database has historically gone down.",
        "**davidhyde**: Seems like using memory mapped files for a write-only load is the sub optimal choice. Maybe I’m mistaken but surely using an append-only file handle would be simpler than changing the behaviour of how memory mapped files are cached like they did for their solution?",
        "**addisonj**: I am going to write this comment with a large preface: I don&#x27;t think it is ever helpful to be an absolutist. For every best-practice&#x2F;&quot;right way&quot; to do things, there are circumstances when doing it another way makes sense. That can be a ton of reasons for that, be it technical, money&#x2F;time, etc. The best engineering teams aren&#x27;t those that just blindly follow what others say is a best practice but understand the options and make an informed choice. None of the following comment is at all commentary on questDB, as they mention in the article,  many  databases use similar tools. With that said, after reading the first paragraph I immediately searched the article for &quot;mmap&quot; and had a good sense of where the rest of this was going. Put simply, it is just really hard to consider what the OS is going to do in all situations when using mmap. Based on my experience, I would guess that a  ton  of people reading this comment have hit issues that, I would argue, is due to using mmap. (Particularly looking at you prometheus). All things told, this is a pretty innocuous incident of mmap causing problems, but I would encourage any aspiring DB engineers to read  https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;mmap-cidr2022  as it gives a great overview of the range of problems that can occur when using mmap I think some would argue that mmap is &quot;fine&quot; for append only workloads (and is certainly more reasonable compared to a DB with arbitrary updates) but even here, lots of factors like metadata, scaling number of tables, etc will  eventually  bring you to hit some fundamental problems when using mmap. The interesting opportunity in my mind, especially with improvements in async IO (both at FS level and in tools like rust), is to build higher level abstractions that bring the &quot;simplicity&quot; of mmap, but with more purpose-built semantics ideal for databases.",
        "**0xbadcafebee**: There are other methods you can use to increase performance under memory pressure, but you&#x27;d end up handling i&#x2F;o directly and maintaining your own index of memory and disk accesses, page-aligned reads&#x2F;writes, etc. It would be easier to just require your users buy more memory, but when there&#x27;s a hack like this available, that seems preferable to implementing your own VMM and disk i&#x2F;o subsystem."
      ]
    }
  },
  {
    "id": "questdb-community_hn-2bef65c5f3b0",
    "origin": "questdb",
    "source_type": "community_hn",
    "url": "https://news.ycombinator.com/item?id=39467885",
    "title": "The Billion Row Challenge (1BRC) – Step-by-Step from 71s to 1.7s",
    "text": "# The Billion Row Challenge (1BRC) – Step-by-Step from 71s to 1.7s\n\nHN Discussion: https://news.ycombinator.com/item?id=39467885\nOriginal URL: https://questdb.io/blog/billion-row-challenge-step-by-step/\n\n## Top Comments\n\n**haxen**: Cool, I see mfiguiere linked to my recent blog post! Let me share a few words about it... I took part in the One Billion Row challenge (1BRC). It was a lot of fun, but also a great learning experience. People came up with some pretty incredible optimization tricks. When you put them all together, it&#x27;s a huge number, and they are all mingled up in individual solutions. They also happen on many levels -- from quite high, to incredibly low and detailed. In retrospect, I could see there was a good number of tricks that are relatively easy to grasp, and reusable in other projects. I felt the urge to do a writeup that captures this knowledge in one place, isolating and explaining each of the tricks.\n\n---\n\n**compsciphd**: I wonder if using a trie instead of a hash would have provided a performance win. if you&#x27;re parsing the file row by row, iterating over the trie as you process each character (as they argue to calculate the int value) (so what you have to do to hash it anyways), should be similar.  What you&#x27;d end up in is micro-architectual issues on cache performance.\n\n---\n\n**scottlamb**: Fun read. I haven&#x27;t used Java in a long time, so even the &quot;idiomatic Java code that would pass muster with any seasoned Java developer&quot; was a bit shocking. I know it&#x27;s a cliche that someone brings up Rust in any programming thread, but I can&#x27;t help myself. ;-) Several of the techniques here are easy enough in Rust that I just do them routinely. * Rayon makes it easy to process line-wise in reasonable-sized chunks without allocating a string per line. * The standard integer parsing stuff takes a slice, not an owned string. * The standard hash map doesn&#x27;t have the same expectation &quot;that we pass in an instance of the key class that is equal to an existing instance&quot;; you can call HashMap&lt;String&gt;::get with a &amp;str. (One limitation is that std::collections::HashMap::entry does expect a K, so there&#x27;s some redundancy if you need to insert afterward, but you could drop to hashbrown::HashMap::raw_entry_mut to avoid that.)\n\n---\n\n**gunnarmorling**: What an excellent post, one of the best on 1BRC I&#x27;ve come across so far. Big shout-out to Marko for participating in the challenge, making a strong push for clarifying corner cases of the rules, and sharing his experiences in this amazing write-up!\n\n---\n\n**Keyframe**: I must admit I only glanced at the article and in the past when topic appeared. How does this work, the speed of 1.7s I mean? Taking a look at input, let&#x27;s say average entry is 16 bytes, there&#x27;s billion of it; That&#x27;s ~16GB. Average read speed of SSDs is what, ~500MB&#x2F;s? Scanning alone at max throughput will take half a minute. This must be relying on DDR4+ read speeds which would probably come in under a second in certain cases. Is that&#x27;s what&#x27;s going on, RAM disk?",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "positive",
    "word_count": 511,
    "metadata": {
      "hn_id": 39467885,
      "points": 274,
      "num_comments": 41,
      "author": "mfiguiere",
      "created_at": "2024-02-22T14:49:07Z",
      "top_comments": [
        "**haxen**: Cool, I see mfiguiere linked to my recent blog post! Let me share a few words about it... I took part in the One Billion Row challenge (1BRC). It was a lot of fun, but also a great learning experience. People came up with some pretty incredible optimization tricks. When you put them all together, it&#x27;s a huge number, and they are all mingled up in individual solutions. They also happen on many levels -- from quite high, to incredibly low and detailed. In retrospect, I could see there was a good number of tricks that are relatively easy to grasp, and reusable in other projects. I felt the urge to do a writeup that captures this knowledge in one place, isolating and explaining each of the tricks.",
        "**compsciphd**: I wonder if using a trie instead of a hash would have provided a performance win. if you&#x27;re parsing the file row by row, iterating over the trie as you process each character (as they argue to calculate the int value) (so what you have to do to hash it anyways), should be similar.  What you&#x27;d end up in is micro-architectual issues on cache performance.",
        "**scottlamb**: Fun read. I haven&#x27;t used Java in a long time, so even the &quot;idiomatic Java code that would pass muster with any seasoned Java developer&quot; was a bit shocking. I know it&#x27;s a cliche that someone brings up Rust in any programming thread, but I can&#x27;t help myself. ;-) Several of the techniques here are easy enough in Rust that I just do them routinely. * Rayon makes it easy to process line-wise in reasonable-sized chunks without allocating a string per line. * The standard integer parsing stuff takes a slice, not an owned string. * The standard hash map doesn&#x27;t have the same expectation &quot;that we pass in an instance of the key class that is equal to an existing instance&quot;; you can call HashMap&lt;String&gt;::get with a &amp;str. (One limitation is that std::collections::HashMap::entry does expect a K, so there&#x27;s some redundancy if you need to insert afterward, but you could drop to hashbrown::HashMap::raw_entry_mut to avoid that.)",
        "**gunnarmorling**: What an excellent post, one of the best on 1BRC I&#x27;ve come across so far. Big shout-out to Marko for participating in the challenge, making a strong push for clarifying corner cases of the rules, and sharing his experiences in this amazing write-up!",
        "**Keyframe**: I must admit I only glanced at the article and in the past when topic appeared. How does this work, the speed of 1.7s I mean? Taking a look at input, let&#x27;s say average entry is 16 bytes, there&#x27;s billion of it; That&#x27;s ~16GB. Average read speed of SSDs is what, ~500MB&#x2F;s? Scanning alone at max throughput will take half a minute. This must be relying on DDR4+ read speeds which would probably come in under a second in certain cases. Is that&#x27;s what&#x27;s going on, RAM disk?"
      ]
    }
  }
]