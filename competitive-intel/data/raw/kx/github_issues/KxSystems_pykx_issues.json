[
  {
    "id": "kx-github_issue-a5711de7b2ae",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/7",
    "title": "Is there a way to suppress empty output (::) when using the magic %%q in Jupyter notebook?",
    "text": "# Is there a way to suppress empty output (::) when using the magic %%q in Jupyter notebook?\n\n**Is your feature request related to a problem? Please describe.**\r\nWhen using the `%%q` magic with in jupyter notebook, it seems that the output from each line of code is printed, including `::`. See, e.g., the example on the [documentation](https://code.kx.com/pykx/2.1/getting-started/q_magic_command.html). Is there a way to suppress empty output (`::`)?\r\n\r\n![1697212278056](https://github.com/KxSystems/pykx/assets/37801658/3faa0ae1-d504-427c-ab81-ad22ef5f2854)\r\n\r\n\r\n**Describe the solution you'd like**\r\nI expect either of the following (or add an option in the `%%q` magic):\r\n* all output of `::` to be removed; or \r\n* only the output of the last line of code in a cell is printed with all results of previous lines removed (even if that line is not ended with `;`).\r\n\r\n**Describe alternatives you've considered**\r\nI tried to add `;` to each line of code, but still a `::` is printed for each line of code ended with `;`. \r\n\r\n\n\n## Top Comments\n\n**cmccarthy1**: Hi @flcong ,\r\n\r\nThanks for submitting this, the team and I will take a look at this and aim to introduce a fix for this in a later release. I believe the correct solution for this will be to output only the last line of code but will survey other users as to desired behaviour/providing an opt-in solution to provide both while removing the returned `::`\n\n---\n\n**flcong**: > Hi @flcong ,\r\n> \r\n> Thanks for submitting this, the team and I will take a look at this and aim to introduce a fix for this in a later release. I believe the correct solution for this will be to output only the last line of code but will survey other users as to desired behaviour/providing an opt-in solution to provide both while removing the returned `::`\r\n\r\nI agree. Thanks a lot!\n\n---\n\n**flcong**: It seems to be an easy fix, by modifying the following line:\r\n\r\nhttps://github.com/KxSystems/pykx/blob/1cddd767d5a324b34020facb9be3569c6101e949/src/pykx/nbextension.py#L106-L107\r\n\r\nProbably for completeness, another option to the q magic can be added, e.g. `--verbatim`, which triggers printing output of each line.\r\n\r\nHappy to create a PR.\n\n---\n\n**flcong**: By the way, not sure why, but `pykx.q('1') == pykx.q('::')` and `pykx.q('1') != pykx.q('::')` both return `pykx.BooleanAtom(pykx.q('0b'))`. Yet, `pykx.q('::') == pykx.q('::')` returns `pykx.BooleanAtom(pykx.q('1b'))` and `pykx.q('::') != pykx.q('::')` returns `pykx.BooleanAtom(pykx.q('0b'))`\n\n---\n\n**flcong**: As an interim solution, I mimics https://github.com/KxSystems/pykx/blob/main/src/pykx/nbextension.py) to define a new magic `qq`. In my usecase, I don't mind adding the definition at the top of each notebook, so I just add the following code to define a new magic command `%%qq` to do the same stuff. I also don't use any options of the PyKX q magic command, so I remove those code.\r\n```python\r\nimport pykx as kx\r\nfrom IPython.core.magic import register_cell_magic\r\n\r\n@register_cell_magic\r\ndef qq(instructions, code):\r\n    ld = kx.SymbolAtom('.Q.pykxld')\r\n    _q = kx.q\r\n    code = [kx.CharVector(x) for x in code.split('\\n')][:-1]\r\n    ret = _q(\r\n        \"{[ld;code;file] value (@';\\\"q\\\";enlist[file],/:value(ld;code))}\",\r\n        ld,\r\n        code,\r\n        b'jupyter_cell.q'\r\n    )\r\n    if not ret[-1] == kx.q('::'):\r\n        print(_q('{x y}', ret, kx.q.count(ret)-1)\r\n```\n\n---\n\n**rianoc-kx**: https://code.kx.com/pykx/2.1/release-notes/changelog.html#fixes-and-improvements_1\r\n\r\n* PyKX 2.0.0 - Fixed an issue where inequality checks would return False incorrectly\r\n\r\n\r\n```\r\n>>> import pykx\r\n>>> pykx.q('1') != pykx.q('::')\r\npykx.BooleanAtom(pykx.q('1b'))\r\n>>> pykx.q('1') == pykx.q('::')\r\npykx.BooleanAtom(pykx.q('0b'))\r\n>>> pykx.__version__\r\n'2.1.1'\r\n```\n\n---\n\n**rianoc-kx**: If you want cells with multiple outputs you can use:\r\n\r\n```\r\nimport pykx as kx\r\nfrom IPython.core.magic import register_cell_magic\r\n\r\n@register_cell_magic\r\ndef qq(instructions, code):\r\n    ld = kx.SymbolAtom('.Q.pykxld')\r\n    _q = kx.q\r\n    code = [kx.CharVector(x) for x in code.split('\\n')][:-1]\r\n    ret = _q(\r\n        \"{[ld;code;file] {x where not (::)~/:x}value (@';\\\"q\\\";enlist[file],/:value(ld;code))}\",\r\n        ld,\r\n        code,\r\n        b'jupyter_cell.q'\r\n    )\r\n    if not kx.licensed:\r\n        ret = ret.py()\r\n    for i in range(len(ret)):\r\n        print(_q('{x y}', ret, i))     \r\n```\r\n\r\n.i.e For the cell\r\n```\r\n%%qq\r\na:1+2\r\na\r\nb:3+3\r\nb\r\nc:2+2\r\n```\r\n\r\nYou will see\r\n```\r\n3\r\n6\r\n```\r\n\r\nYour example code would print nothing as the last item returns `(::)`.\r\n\r\nOur planned change will suppress `(::)` prints but will allow multiple lines to display. This will be done to match how `q` would behave if you loaded the same code from the cell from a `.q` file with `\\l`\r\n\r\n This change and some other improvements to Jupyter magic `%%q` will be included in the next release of PyKX - we will notify you when it is available.\n\n---\n\n**flcong**: > If you want cells with multiple outputs you can use:\r\n> \r\n> ```\r\n> import pykx as kx\r\n> from IPython.core.magic import register_cell_magic\r\n> \r\n> @register_cell_magic\r\n> def qq(instructions, code):\r\n>     ld = kx.SymbolAtom('.Q.pykxld')\r\n>     _q = kx.q\r\n>     code = [kx.CharVector(x) for x in code.split('\\n')][:-1]\r\n>     ret = _q(\r\n>         \"{[ld;code;file] {x where not (::)~/:x}value (@';\\\"q\\\";enlist[file],/:value(ld;code))}\",\r\n>         ld,\r\n>         code,\r\n>         b'jupyter_cell.q'\r\n>     )\r\n>     if not kx.licensed:\r\n>         ret = ret.py()\r\n>     for i in range(len(ret)):\r\n>         print(_q('{x y}', ret, i))     \r\n> ```\r\n> \r\n> .i.e For the cell\r\n> \r\n> ```\r\n> %%qq\r\n> a:1+2\r\n> a\r\n> b:3+3\r\n> b\r\n> c:2+2\r\n> ```\r\n> \r\n> You will see\r\n> \r\n> ```\r\n> 3\r\n> 6\r\n> ```\r\n> \r\n> Your example code would print nothing as the last item returns `(::)`.\r\n> \r\n> Our planned change will suppress `(::)` prints but will allow multiple lines to display. This will be done to match how `q` would behave if you loaded the same code from the cell from a `.q` file with `\\l`\r\n> \r\n> This change and some other improvements to Jupyter magic `%%q` will be included in the next release of PyKX - we will notify you when it is available.\r\n\r\nThanks! That makes sense!\n\n---\n\n**cmccarthy1**: Hi @flcong,\r\n\r\nThe fix for this has been merged into the main branch and released on PyPI in version 2.2 of the library. Please reopen the issue if you still see any problems. Thanks again for raising this it's a really nice improvement to the UX for the q development side of the library.\r\n\r\nConor",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 955,
    "metadata": {
      "issue_number": 7,
      "state": "closed",
      "labels": [],
      "comments_count": 9,
      "created_at": "2023-10-13T16:00:30Z",
      "updated_at": "2023-11-09T10:14:31Z",
      "closed_at": "2023-11-09T10:14:30Z",
      "author": "flcong",
      "top_comments": [
        "**cmccarthy1**: Hi @flcong ,\r\n\r\nThanks for submitting this, the team and I will take a look at this and aim to introduce a fix for this in a later release. I believe the correct solution for this will be to output only the last line of code but will survey other users as to desired behaviour/providing an opt-in solution to provide both while removing the returned `::`",
        "**flcong**: > Hi @flcong ,\r\n> \r\n> Thanks for submitting this, the team and I will take a look at this and aim to introduce a fix for this in a later release. I believe the correct solution for this will be to output only the last line of code but will survey other users as to desired behaviour/providing an opt-in solution to provide both while removing the returned `::`\r\n\r\nI agree. Thanks a lot!",
        "**flcong**: It seems to be an easy fix, by modifying the following line:\r\n\r\nhttps://github.com/KxSystems/pykx/blob/1cddd767d5a324b34020facb9be3569c6101e949/src/pykx/nbextension.py#L106-L107\r\n\r\nProbably for completeness, another option to the q magic can be added, e.g. `--verbatim`, which triggers printing output of each line.\r\n\r\nHappy to create a PR.",
        "**flcong**: By the way, not sure why, but `pykx.q('1') == pykx.q('::')` and `pykx.q('1') != pykx.q('::')` both return `pykx.BooleanAtom(pykx.q('0b'))`. Yet, `pykx.q('::') == pykx.q('::')` returns `pykx.BooleanAtom(pykx.q('1b'))` and `pykx.q('::') != pykx.q('::')` returns `pykx.BooleanAtom(pykx.q('0b'))`",
        "**flcong**: As an interim solution, I mimics https://github.com/KxSystems/pykx/blob/main/src/pykx/nbextension.py) to define a new magic `qq`. In my usecase, I don't mind adding the definition at the top of each notebook, so I just add the following code to define a new magic command `%%qq` to do the same stuff. I also don't use any options of the PyKX q magic command, so I remove those code.\r\n```python\r\nimport pykx as kx\r\nfrom IPython.core.magic import register_cell_magic\r\n\r\n@register_cell_magic\r\ndef qq(instructions, code):\r\n    ld = kx.SymbolAtom('.Q.pykxld')\r\n    _q = kx.q\r\n    code = [kx.CharVector(x) for x in code.split('\\n')][:-1]\r\n    ret = _q(\r\n        \"{[ld;code;file] value (@';\\\"q\\\";enlist[file],/:value(ld;code))}\",\r\n        ld,\r\n        code,\r\n        b'jupyter_cell.q'\r\n    )\r\n    if not ret[-1] == kx.q('::'):\r\n        print(_q('{x y}', ret, kx.q.count(ret)-1)\r\n```"
      ],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-3ecb486598ac",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/35",
    "title": "libpython error when using \"Python in q\" functionality",
    "text": "# libpython error when using \"Python in q\" functionality\n\n**Describe the bug**\r\nWhen importing PyKx into a q session (i.e. `\\l pykx.q`), a `'libpython` error is returned. This can be fixed by symlinking libpython*.so (see below), but this shouldn't be necessary.\r\n\r\n**To Reproduce**\r\nDockerfile\r\n```\r\nFROM ubuntu:22.04\r\n\r\nWORKDIR /work\r\n\r\nCOPY prep/l64.zip /work\r\nCOPY prep/kc.lic /work\r\n\r\nENV QHOME=/work/kdb\r\n\r\nRUN apt-get update && \\\r\n apt-get install -y python3.10 python3.10-venv libpython3.10 unzip curl\r\n \r\nRUN unzip l64.zip -d kdb && \\\r\n python3.10 -m venv .venv && \\\r\n . .venv/bin/activate && \\\r\n pip install pykx find-libpython && \\\r\n python -c \"import pykx;pykx.install_into_QHOME(to_local_folder=True)\" \r\n```\r\nThen\r\n```\r\nsudo docker build . --tag pykx\r\nsudo docker run --rm -it pykx\r\n```\r\nThen\r\n```\r\n. .venv/bin/activate\r\nkdb/l64/q\r\n\\l pykx.q\r\n```\r\n_--> Doesn't work with libpython error_\r\n\r\n\r\n**To Fix**\r\n```\r\nln -s /usr/lib/x86_64-linux-gnu/libpython3.10.so.1 /usr/lib/x86_64-linux-gnu/libpython3.10.so\r\nkdb/l64/q\r\n\\l pykx.q\r\n```\r\n_--> Does work_\r\n\r\n\r\n**Expected behavior**\r\nPyKx should work without having to symlink libpython. The find-libpython Python package successfully returns the correct path, and is mentioned in your docs as a dependency. Perhaps this should be used?\r\n```\r\n>>> from find_libpython import find_libpython\r\n>>> find_libpython()\r\n'/usr/lib/x86_64-linux-gnu/libpython3.10.so.1.0'\r\n```\r\n\r\nIf [L5-12 from embedPy](https://github.com/KxSystems/embedPy/blob/master/p.q#L5) lives on in PyKx, that could explain the issue, as the \"L\" variable returns the incorrect path to libpython.\r\n\n\n## Top Comments\n\n**cmccarthy1**: Hey @erichards97\r\n\r\nThanks for raising this! We can look into what we can do to improve the experience of this.\r\n\r\nWe have relied directly on find-libpython in the past (prior to 1.6.1) but we had seen issues with this not finding the correct shared object for the Python version that's being used in complex user environments and on Windows.\r\n\r\nThere is an environment variable `PYKX_PYTHON_LIB_PATH` which you can set to the path of the shared object that you wish to use should you not want to create the symlink. In your case this would be something akin to\r\n\r\n```bash\r\nexport PYKX_PYTHON_LIB_PATH= '/usr/lib/x86_64-linux-gnu/libpython3.10.so.1.0'\r\n```\r\n\r\nI'll try to provide an update in the week or so once we have had a chance to look into options\n\n---\n\n**cmccarthy1**: Hey @erichards97\r\n\r\nFundamentally I think we're a little stuck in the requirement for the split between how the search works but the following is a workaround which while manual for the moment I can look to include as part of a patch in the next couple of weeks\r\n\r\nThe following mimics what I'm considering adding\r\n\r\n```\r\nFROM ubuntu:22.04\r\n\r\nWORKDIR /work\r\n\r\nCOPY prep/l64.zip /work\r\nCOPY prep/kc.lic /work\r\n\r\nENV QHOME=/work/kdb\r\nENV PYKX_USE_FIND_LIBPYTHON=True\r\n\r\nRUN apt-get update && \\\r\n apt-get install -y python3.10 python3.10-venv libpython3.10 unzip curl\r\n \r\nRUN unzip l64.zip -d kdb && \\\r\n python3.10 -m venv .venv && \\\r\n . .venv/bin/activate && \\\r\n pip install pykx find-libpython && \\\r\n python -c \"import pykx;pykx.install_into_QHOME(to_local_folder=True)\" && \\\r\n sed -i '71i if[\"true\"~lower getenv `PYKX_USE_FIND_LIBPYTHON;setenv[`PYKX_PYTHON_LIB_PATH;raze system util.whichPython,\" -c\\\\\"from find_libpython import find_libpython;print(find_libpython())\\\\\"\"]];' /work/pykx.q\r\n```\r\n\r\nEssentially adding an env-var to choose the use of find-libpython and then using this to set the `PYKX_PYTHON_LIB_PATH` for a user rather than requiring you to dynamically set it.\n\n---\n\n**erichards97**: Thanks for digging into this @cmccarthy1 .\r\n\r\nWe've verified that `find-libpython` returns the correct path in all of our setups, so the proposed env var sounds good to us. Please let us know if this makes its way into a future PyKx release.\n\n---\n\n**erichards97**: Hi @cmccarthy1 - do you know if this functionality will be added in a future release? Many thanks\n\n---\n\n**cmccarthy1**: Hey @erichards97,\r\n\r\nYes, the intention is that we'll be adding something for this either in our 3.0 or 3.1 release so will have a fix for this before the end of the year.\n\n---\n\n**rianoc-kx**: PyKX 3.0 been released which includes:\r\n\r\n> Addition of support for new environment variable PYKX_USE_FIND_LIBPYTHON which will use the Python package [find_libpython](https://pypi.org/project/find-libpython/) to specify the location from which libpython.[so|dll] will be taken.\r\n\r\nhttps://code.kx.com/pykx/3.0/release-notes/underq-changelog.html#additions\r\n\r\nUsage:\r\nhttps://code.kx.com/pykx/3.0/user-guide/configuration.html#pykx-qargs-supported-additions \r\n\r\n",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 629,
    "metadata": {
      "issue_number": 35,
      "state": "closed",
      "labels": [],
      "comments_count": 6,
      "created_at": "2024-09-02T15:57:33Z",
      "updated_at": "2024-11-14T10:51:06Z",
      "closed_at": "2024-11-14T10:51:06Z",
      "author": "erichards97",
      "top_comments": [
        "**cmccarthy1**: Hey @erichards97\r\n\r\nThanks for raising this! We can look into what we can do to improve the experience of this.\r\n\r\nWe have relied directly on find-libpython in the past (prior to 1.6.1) but we had seen issues with this not finding the correct shared object for the Python version that's being used in complex user environments and on Windows.\r\n\r\nThere is an environment variable `PYKX_PYTHON_LIB_PATH` which you can set to the path of the shared object that you wish to use should you not want to create the symlink. In your case this would be something akin to\r\n\r\n```bash\r\nexport PYKX_PYTHON_LIB_PATH= '/usr/lib/x86_64-linux-gnu/libpython3.10.so.1.0'\r\n```\r\n\r\nI'll try to provide an update in the week or so once we have had a chance to look into options",
        "**cmccarthy1**: Hey @erichards97\r\n\r\nFundamentally I think we're a little stuck in the requirement for the split between how the search works but the following is a workaround which while manual for the moment I can look to include as part of a patch in the next couple of weeks\r\n\r\nThe following mimics what I'm considering adding\r\n\r\n```\r\nFROM ubuntu:22.04\r\n\r\nWORKDIR /work\r\n\r\nCOPY prep/l64.zip /work\r\nCOPY prep/kc.lic /work\r\n\r\nENV QHOME=/work/kdb\r\nENV PYKX_USE_FIND_LIBPYTHON=True\r\n\r\nRUN apt-get update && \\\r\n apt-get install -y python3.10 python3.10-venv libpython3.10 unzip curl\r\n \r\nRUN unzip l64.zip -d kdb && \\\r\n python3.10 -m venv .venv && \\\r\n . .venv/bin/activate && \\\r\n pip install pykx find-libpython && \\\r\n python -c \"import pykx;pykx.install_into_QHOME(to_local_folder=True)\" && \\\r\n sed -i '71i if[\"true\"~lower getenv `PYKX_USE_FIND_LIBPYTHON;setenv[`PYKX_PYTHON_LIB_PATH;raze system util.whichPython,\" -c\\\\\"from find_libpython import find_libpython;print(find_libpython())\\\\\"\"]];' /work/pykx.q\r\n```\r\n\r\nEssentially adding an env-var to choose the use of find-libpython and then using this to set the `PYKX_PYTHON_LIB_PATH` for a user rather than requiring you to dynamically set it.",
        "**erichards97**: Thanks for digging into this @cmccarthy1 .\r\n\r\nWe've verified that `find-libpython` returns the correct path in all of our setups, so the proposed env var sounds good to us. Please let us know if this makes its way into a future PyKx release.",
        "**erichards97**: Hi @cmccarthy1 - do you know if this functionality will be added in a future release? Many thanks",
        "**cmccarthy1**: Hey @erichards97,\r\n\r\nYes, the intention is that we'll be adding something for this either in our 3.0 or 3.1 release so will have a fix for this before the end of the year."
      ],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-a4fbe78759f4",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/23",
    "title": "Addition of isnull, isna, notnull, notna, idxmax, idxmin, kurt and sem functions",
    "text": "# Addition of isnull, isna, notnull, notna, idxmax, idxmin, kurt and sem functions\n\n---\r\nname: Addition of isnull, isna, notnull, notna, idxmax, idxmin, kurt and sem functions.\r\nabout: Missing pandas API functionality\r\ntitle: 'Addition of isnull, isna, notnull, notna, idxmax, idxmin, kurt and sem functions.'\r\nlabels:  ''\r\nassignees: '@nipsn @tortolavivo23 @neutropolis @MiguelGomezC'\r\n\r\n---\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\nNo\r\n\r\n**Describe the solution you'd like**\r\nAn implementation of said functions.\r\n\r\n**Describe alternatives you've considered**\r\n\r\n\r\n**Additional resource**\r\nLinks to pandas documentation of said functions:\r\n\r\n- https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.isnull.html\r\n- https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.isna.html\r\n- https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.notnull.html\r\n- https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.notna.html\r\n- https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.idxmax.html\r\n- https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.idxmin.html\r\n- https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.kurt.html\r\n- https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sem.html\r\n\r\n\n\n## Top Comments\n\n**rianoc-kx**: https://pypi.org/project/pykx/2.5.1/\r\n\r\nhttps://code.kx.com/pykx/2.5/release-notes/changelog.html#pykx-251\r\n\r\n**Additions**\r\nPandas API additions: `isnull`, `isna`, `notnull`, `notna`, `idxmax`, `idxmin`, `kurt`, `sem`.\r\n\r\n\r\nThanks for the contributions!\n\n---\n\n**rianoc-kx**: Some small changes I made you will see in the final 2.5.1 MR https://github.com/KxSystems/pykx/pull/31/files\r\n\r\n\r\n[src/pykx/pandas_api/pandas_meta.py](https://github.com/KxSystems/pykx/pull/31/files#diff-07a8a9f894f2c95141c559e597f59c7e844c47f663956c528f37b2d6e95a04b3)\r\n\r\nAddition of these lines so behaviour with Keyed tables is consistent across the APIs.\r\n.i.e the operation only runs on the value columns, not the key columns\r\n\r\n```q\r\n        if 'Keyed' in str(type(tab)):\r\n            tab = q('value', tab)\r\n```\r\n\r\n[tests/test_pandas_api.py](https://github.com/KxSystems/pykx/pull/31/files#diff-da3fe012e584c65cb900f5efb3c636a7c1d9080dee0e7309230828e1eb868157)\r\nI removed the symbol column when testing with the `numeric_only=False` default value.\r\nThis is because we support both Pandas 1.* and 2.* but 1.* tests were failing because sorting string columns were not allowed.\r\n\r\nPandas 2.1.4\r\n```q\r\n>>> import pykx as kx\r\n>>> tab = kx.q('([] sym: 100?`foo`bar`baz`qux; price: 250.0f - 100?500.0f; ints: 100 - 100?200)')\r\n>>> tab.pd().idxmin()\r\nsym       0\r\nprice    22\r\nints     44\r\ndtype: int64\r\n```\r\n\r\nPandas 1.5.3\r\n\r\n```q\r\n>>> import pykx as kx\r\n>>> tab = kx.q('([] sym: 100?`foo`bar`baz`qux; price: 250.0f - 100?500.0f; ints: 100 - 100?200)')\r\n>>> tab.pd().idxmin()\r\n...\r\nTypeError: reduction operation 'argmin' not allowed for this dtype\r\n```\r\n\r\n\r\n\n\n---\n\n**nipsn**: Hi Rian!\r\nThanks for keeping us up to date with these changes.\r\n\r\nI have one question then: I noticed that in the README you mention how `pandas>=1.2, < 2.2.0` versions are supported. However, when setting up the dev environment, pip did of course only pull the latest version that matched the specification.\r\n\r\nDo you know of a way to be able to test both pandas major versions at once? The best solution that comes to mind would be to have two Python virtual environments with these two major versions and switching back and forth, but it might turn cumbersome in the long run...\n\n---\n\n**rianoc-kx**: We have gitlab testing pipelines which run in both versions as soon as we push. \r\nWe do also test manually by uninstalling one version and installing the other locally as well.\r\n\r\nTo make this less cumbersome a function could be added to your `~/.bashrc`:\r\n```bash\r\np1p2 () {\r\n python -m pip install pandas==1.5.3 && \\\r\n eval \"$@\" && \\\r\n python -m pip install pandas==2.1.4 && \\\r\n eval \"$@\"\r\n}\r\n```\r\n\r\nThen the test will run on both versions:\r\n```bash\r\np1p2 python -m pytest -vvv -n 0 --no-cov --junitxml=report.xml tests/test_pandas_api.py::test_pandas_idxmin\r\n```\r\n\r\nWe'll research/think about making this easier going forward\n\n---\n\n**nipsn**: That checks out!\r\nI'll try it next time around",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 498,
    "metadata": {
      "issue_number": 23,
      "state": "closed",
      "labels": [],
      "comments_count": 5,
      "created_at": "2024-02-13T12:26:30Z",
      "updated_at": "2024-06-12T12:21:57Z",
      "closed_at": "2024-06-11T14:53:56Z",
      "author": "nipsn",
      "top_comments": [
        "**rianoc-kx**: https://pypi.org/project/pykx/2.5.1/\r\n\r\nhttps://code.kx.com/pykx/2.5/release-notes/changelog.html#pykx-251\r\n\r\n**Additions**\r\nPandas API additions: `isnull`, `isna`, `notnull`, `notna`, `idxmax`, `idxmin`, `kurt`, `sem`.\r\n\r\n\r\nThanks for the contributions!",
        "**rianoc-kx**: Some small changes I made you will see in the final 2.5.1 MR https://github.com/KxSystems/pykx/pull/31/files\r\n\r\n\r\n[src/pykx/pandas_api/pandas_meta.py](https://github.com/KxSystems/pykx/pull/31/files#diff-07a8a9f894f2c95141c559e597f59c7e844c47f663956c528f37b2d6e95a04b3)\r\n\r\nAddition of these lines so behaviour with Keyed tables is consistent across the APIs.\r\n.i.e the operation only runs on the value columns, not the key columns\r\n\r\n```q\r\n        if 'Keyed' in str(type(tab)):\r\n            tab = q('value', tab)\r\n```\r\n\r\n[tests/test_pandas_api.py](https://github.com/KxSystems/pykx/pull/31/files#diff-da3fe012e584c65cb900f5efb3c636a7c1d9080dee0e7309230828e1eb868157)\r\nI removed the symbol column when testing with the `numeric_only=False` default value.\r\nThis is because we support both Pandas 1.* and 2.* but 1.* tests were failing because sorting string columns were not allowed.\r\n\r\nPandas 2.1.4\r\n```q\r\n>>> import pykx as kx\r\n>>> tab = kx.q('([] sym: 100?`foo`bar`baz`qux; price: 250.0f - 100?500.0f; ints: 100 - 100?200)')\r\n>>> tab.pd().idxmin()\r\nsym       0\r\nprice    22\r\nints     44\r\ndtype: int64\r\n```\r\n\r\nPandas 1.5.3\r\n\r\n```q\r\n>>> import pykx as kx\r\n>>> tab = kx.q('([] sym: 100?`foo`bar`baz`qux; price: 250.0f - 100?500.0f; ints: 100 - 100?200)')\r\n>>> tab.pd().idxmin()\r\n...\r\nTypeError: reduction operation 'argmin' not allowed for this dtype\r\n```\r\n\r\n\r\n",
        "**nipsn**: Hi Rian!\r\nThanks for keeping us up to date with these changes.\r\n\r\nI have one question then: I noticed that in the README you mention how `pandas>=1.2, < 2.2.0` versions are supported. However, when setting up the dev environment, pip did of course only pull the latest version that matched the specification.\r\n\r\nDo you know of a way to be able to test both pandas major versions at once? The best solution that comes to mind would be to have two Python virtual environments with these two major versions and switching back and forth, but it might turn cumbersome in the long run...",
        "**rianoc-kx**: We have gitlab testing pipelines which run in both versions as soon as we push. \r\nWe do also test manually by uninstalling one version and installing the other locally as well.\r\n\r\nTo make this less cumbersome a function could be added to your `~/.bashrc`:\r\n```bash\r\np1p2 () {\r\n python -m pip install pandas==1.5.3 && \\\r\n eval \"$@\" && \\\r\n python -m pip install pandas==2.1.4 && \\\r\n eval \"$@\"\r\n}\r\n```\r\n\r\nThen the test will run on both versions:\r\n```bash\r\np1p2 python -m pytest -vvv -n 0 --no-cov --junitxml=report.xml tests/test_pandas_api.py::test_pandas_idxmin\r\n```\r\n\r\nWe'll research/think about making this easier going forward",
        "**nipsn**: That checks out!\r\nI'll try it next time around"
      ],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-2f8a9eefd821",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/22",
    "title": "Passing a DataFrame with datetime64[us] to kdb errors",
    "text": "# Passing a DataFrame with datetime64[us] to kdb errors\n\n**Describe the bug**\r\nCalling a KDB function over IPC and providing a DataFrame as an argument that contains a column of `datetime64[us]` results in an error: _TypeError: ktype cannot be inferred from Numpy dtype datetime64[us]_\r\n\r\nI imagine `datetime64[ns]` is the standard pandas/numpy type, however we receive `us` when pulling data from a SQL database using turbodbc (which we're then trying to send to KDB), and converting between the two types feels unnecessary.\r\n\r\n**To Reproduce**\r\n`q('myfunction', df)`\r\nwhere df has a column of datetime64[us]\r\n\r\n**Expected behavior**\r\nThe df to be converted to a KDB table, with column of type timestamp.\r\n\r\n**Screenshots**\r\nN/A\r\n\r\n**Desktop (please complete the following information):**\r\n- PyKx v2.3.0\r\n\r\n\r\n**Additional context**\r\nN/A\r\n\r\nThanks\n\n## Top Comments\n\n**erichards97**: As a temporary workaround - \r\n`df['COLUMN'] = df['COLUMN'].apply(pd.Timestamp)`\r\nbefore passing to KDB works\n\n---\n\n**rianoc-kx**: We'll open a ticket internally to add support for `datetime[us]`\n\n---\n\n**cmccarthy1**: Hi @erichards97,\r\n\r\nYesterday we released a fix for this with our 2.4.0 version of PyKX, change to support this is [here](https://github.com/KxSystems/pykx/blob/main/src/pykx/toq.pyx#L1306).\r\n\r\nFor full release notes see [here](https://code.kx.com/pykx/2.4/release-notes/changelog.html)\n\n---\n\n**erichards97**: Great, thank you.",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 186,
    "metadata": {
      "issue_number": 22,
      "state": "closed",
      "labels": [],
      "comments_count": 4,
      "created_at": "2024-02-13T09:58:55Z",
      "updated_at": "2024-03-21T09:27:45Z",
      "closed_at": "2024-03-21T09:25:55Z",
      "author": "erichards97",
      "top_comments": [
        "**erichards97**: As a temporary workaround - \r\n`df['COLUMN'] = df['COLUMN'].apply(pd.Timestamp)`\r\nbefore passing to KDB works",
        "**rianoc-kx**: We'll open a ticket internally to add support for `datetime[us]`",
        "**cmccarthy1**: Hi @erichards97,\r\n\r\nYesterday we released a fix for this with our 2.4.0 version of PyKX, change to support this is [here](https://github.com/KxSystems/pykx/blob/main/src/pykx/toq.pyx#L1306).\r\n\r\nFor full release notes see [here](https://code.kx.com/pykx/2.4/release-notes/changelog.html)",
        "**erichards97**: Great, thank you."
      ],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-7bb25ff1043f",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/36",
    "title": "Pykx pandas conversion offers no speedup with short vs float columns",
    "text": "# Pykx pandas conversion offers no speedup with short vs float columns\n\n```\r\nPython: 3.11.8\r\nPandas: 2.2.1\r\nNumpy: 1.26.4\r\n```\r\n\r\nThere seems to be marginal benefit in terms speed when converting kdb tables into pandas using the .pd() method when using short ints instead of floats. Although the memory usage of the table drops accordingly, the time spent in conversion to dataframe does not improve much.\r\n\r\n```\r\nN:50000000;\r\ndat1:([] date:2000.01.01; sym:`A; q1:N?100h; q2:N?5000h; q3:N?50h);\r\ndat2:([] date:2000.01.01; sym:`A; q1:N?100f; q2:N?5000f; q3:N?50f);\r\n\r\n```\r\nIndeed, the size of dat1 is 40% the size of dat2, and yet in python:\r\n```\r\n\r\nhandle = pykx.SyncQConnection(host, port)\r\n%timeit df1 = handle('dat1').pd() #short\r\n%timeit df2 = handle('dat2').pd() #float\r\n```\r\n\r\n```\r\n3.48s per loop\r\n5.76s per loop\r\n```\r\nThis gets closer the more float/short columns you add.\r\n\r\nIs there a way to optimize the call to .pd when dealing with very large tables whose column values are mostly shorts? Otherwise one can spend forever waiting for the conversion.\n\n## Top Comments\n\n**rianoc-kx**: If you are not already using Pandas 2.0 it's worth upgrading as you will see a 3x speed improvement for these conversions.\r\n\r\nPandas 1.5.3\r\n\r\n```\r\nIn [1]: import pykx as kx\r\n\r\nIn [2]: kx.q['N'] =50000000;\r\n   ...: dat1 = kx.q('([] date:2000.01.01; sym:`A; q1:N?100h; q2:N?5000h; q3:N?50h)')\r\n   ...: dat2 = kx.q('([] date:2000.01.01; sym:`A; q1:N?100f; q2:N?5000f; q3:N?50f)')\r\n   ...:\r\n\r\nIn [3]: %timeit df1 = dat1.pd()\r\n2.13 s ± 163 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n\r\nIn [4]: %timeit df2 = dat2.pd()\r\n2.1 s ± 158 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n```\r\n\r\nPandas 2.1.4\r\n\r\n```\r\nIn [1]: import pykx as kx\r\n   ...:\r\n   ...: kx.q['N'] =50000000;\r\n   ...: dat1 = kx.q('([] date:2000.01.01; sym:`A; q1:N?100h; q2:N?5000h; q3:N?50h)')\r\n   ...: dat2 = kx.q('([] date:2000.01.01; sym:`A; q1:N?100f; q2:N?5000f; q3:N?50f)')\r\n   ...:\r\n\r\nIn [2]: %timeit df1 = dat1.pd()\r\n738 ms ± 26.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n\r\nIn [3]: %timeit df2 = dat2.pd()\r\n700 ms ± 27.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n```\n\n---\n\n**antipisa**: @rianoc-kx  this is on pandas 2.2.1. Could you try going over TCP/IP?\n\n---\n\n**rianoc-kx**: Isolating the IPC portion you can see the larger float data is slower to transfer:\r\n\r\n```python\r\nIn [3]: %timeit dat1 = handle('dat1')\r\n1.13 s ± 49.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n\r\nIn [4]: %timeit dat2 = handle('dat2')\r\n1.56 s ± 32.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n```\r\n\r\nRemoving the  `sym` column we can see that this is responsible for the majority on the conversion time: `~700ms` --> `~300ms`\r\n\r\n```python\r\nIn [9]: kx.q['N'] =50000000;\r\n   ...: dat1 = kx.q('([] date:2000.01.01;q1:N?100h; q2:N?5000h; q3:N?50h)')\r\n   ...: dat2 = kx.q('([] date:2000.01.01; q1:N?100f; q2:N?5000f; q3:N?50f)')\r\n\r\nIn [10]: %timeit df1 = dat1.pd()\r\n311 ms ± 13.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n\r\nIn [11]: %timeit df2 = dat2.pd()\r\n270 ms ± 18.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n```\r\n\r\nGoing further again and removing `date` we can see it was responsible for the remaining majority of the conversion time. Leaving only the numeric conversions which are the most direct and therefore fastest:\r\n\r\n```python\r\nIn [12]:  dat1 = kx.q('([] q1:N?100h; q2:N?5000h; q3:N?50h)')\r\n    ...:  dat2 = kx.q('([] q1:N?100f; q2:N?5000f; q3:N?50f)')\r\n\r\nIn [13]: %timeit df1 = dat1.pd()\r\n47.7 ms ± 1.08 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\r\n\r\nIn [14]: %timeit df2 = dat2.pd()\r\n121 µs ± 7.03 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\r\n```\r\n\r\nFloat arrays are able to be zero copied from q to NumPy arrays to build the dataframe which gives this operation making it effectively a constant time operation.\r\n\r\n`short` -> `int` -> `long` does show a progression on conversion time with the datatype size:\r\n\r\n```python\r\nIn [3]:  kx.q['N'] =50000000;\r\n\r\nIn [4]: dat1 = kx.q('([] q1:N?100h; q2:N?5000h; q3:N?50h)')\r\n\r\nIn [5]: %timeit df1 = dat1.pd()\r\n43.8 ms ± 701 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\r\n\r\nIn [6]: dat2 = kx.q('([] q1:N?100i; q2:N?5000i; q3:N?50i)')\r\n\r\nIn [7]: %timeit df2 = dat2.pd()\r\n58.3 ms ± 304 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\r\n\r\nIn [8]: dat3 = kx.q('([] q1:N?100; q2:N?5000; q3:N?50)')\r\n\r\nIn [9]: %timeit df3 = dat3.pd()\r\n97.4 ms ± 685 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\r\n```",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 750,
    "metadata": {
      "issue_number": 36,
      "state": "open",
      "labels": [],
      "comments_count": 3,
      "created_at": "2024-10-09T20:44:19Z",
      "updated_at": "2024-10-11T10:04:55Z",
      "closed_at": null,
      "author": "antipisa",
      "top_comments": [
        "**rianoc-kx**: If you are not already using Pandas 2.0 it's worth upgrading as you will see a 3x speed improvement for these conversions.\r\n\r\nPandas 1.5.3\r\n\r\n```\r\nIn [1]: import pykx as kx\r\n\r\nIn [2]: kx.q['N'] =50000000;\r\n   ...: dat1 = kx.q('([] date:2000.01.01; sym:`A; q1:N?100h; q2:N?5000h; q3:N?50h)')\r\n   ...: dat2 = kx.q('([] date:2000.01.01; sym:`A; q1:N?100f; q2:N?5000f; q3:N?50f)')\r\n   ...:\r\n\r\nIn [3]: %timeit df1 = dat1.pd()\r\n2.13 s ± 163 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n\r\nIn [4]: %timeit df2 = dat2.pd()\r\n2.1 s ± 158 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n```\r\n\r\nPandas 2.1.4\r\n\r\n```\r\nIn [1]: import pykx as kx\r\n   ...:\r\n   ...: kx.q['N'] =50000000;\r\n   ...: dat1 = kx.q('([] date:2000.01.01; sym:`A; q1:N?100h; q2:N?5000h; q3:N?50h)')\r\n   ...: dat2 = kx.q('([] date:2000.01.01; sym:`A; q1:N?100f; q2:N?5000f; q3:N?50f)')\r\n   ...:\r\n\r\nIn [2]: %timeit df1 = dat1.pd()\r\n738 ms ± 26.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n\r\nIn [3]: %timeit df2 = dat2.pd()\r\n700 ms ± 27.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n```",
        "**antipisa**: @rianoc-kx  this is on pandas 2.2.1. Could you try going over TCP/IP?",
        "**rianoc-kx**: Isolating the IPC portion you can see the larger float data is slower to transfer:\r\n\r\n```python\r\nIn [3]: %timeit dat1 = handle('dat1')\r\n1.13 s ± 49.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n\r\nIn [4]: %timeit dat2 = handle('dat2')\r\n1.56 s ± 32.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n```\r\n\r\nRemoving the  `sym` column we can see that this is responsible for the majority on the conversion time: `~700ms` --> `~300ms`\r\n\r\n```python\r\nIn [9]: kx.q['N'] =50000000;\r\n   ...: dat1 = kx.q('([] date:2000.01.01;q1:N?100h; q2:N?5000h; q3:N?50h)')\r\n   ...: dat2 = kx.q('([] date:2000.01.01; q1:N?100f; q2:N?5000f; q3:N?50f)')\r\n\r\nIn [10]: %timeit df1 = dat1.pd()\r\n311 ms ± 13.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n\r\nIn [11]: %timeit df2 = dat2.pd()\r\n270 ms ± 18.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\r\n```\r\n\r\nGoing further again and removing `date` we can see it was responsible for the remaining majority of the conversion time. Leaving only the numeric conversions which are the most direct and therefore fastest:\r\n\r\n```python\r\nIn [12]:  dat1 = kx.q('([] q1:N?100h; q2:N?5000h; q3:N?50h)')\r\n    ...:  dat2 = kx.q('([] q1:N?100f; q2:N?5000f; q3:N?50f)')\r\n\r\nIn [13]: %timeit df1 = dat1.pd()\r\n47.7 ms ± 1.08 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\r\n\r\nIn [14]: %timeit df2 = dat2.pd()\r\n121 µs ± 7.03 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\r\n```\r\n\r\nFloat arrays are able to be zero copied from q to NumPy arrays to build the dataframe which gives this operation making it effectively a constant time operation.\r\n\r\n`short` -> `int` -> `long` does show a progression on conversion time with the datatype size:\r\n\r\n```python\r\nIn [3]:  kx.q['N'] =50000000;\r\n\r\nIn [4]: dat1 = kx.q('([] q1:N?100h; q2:N?5000h; q3:N?50h)')\r\n\r\nIn [5]: %timeit df1 = dat1.pd()\r\n43.8 ms ± 701 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\r\n\r\nIn [6]: dat2 = kx.q('([] q1:N?100i; q2:N?5000i; q3:N?50i)')\r\n\r\nIn [7]: %timeit df2 = dat2.pd()\r\n58.3 ms ± 304 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\r\n\r\nIn [8]: dat3 = kx.q('([] q1:N?100; q2:N?5000; q3:N?50)')\r\n\r\nIn [9]: %timeit df3 = dat3.pd()\r\n97.4 ms ± 685 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\r\n```"
      ],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-11a5d1d167dd",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/55",
    "title": "call_port method doesn't exist in kx.tick.GATEWAY class",
    "text": "# call_port method doesn't exist in kx.tick.GATEWAY class\n\nHi maintainers,\n\nWhile reviewing the documentation at https://github.com/KxSystems/pykx/blob/main/docs/user-guide/advanced/streaming/gateways.md, I noticed a reference to the call_port method, both in the text and in the code examples.\n\nHowever, it appears that the call_port method is not defined in the GATEWAY class. Could you please confirm whether the documentation needs updating?\n\nAdditionally, in the following snippet:\n\n```\ndef gateway_function(table, symbol):\n    rtp = gateway.call_port('rtp', table, symbol)\n    try:\n        hdb = gateway.call_port('hdb', table, symbol)\n    except BaseException:\n        print('Failed to retrieve data from HDB')\n        hdb = 0\n    return rtp + hdb\n```\n\nthe function returns the sum of rtp and hdb. Is this behavior correct and intended?\n\nThanks in advance for your help.\n\nBest regards,\nFabio\n\n## Top Comments\n\n**fabiogaiera**: Hi! Any plans to introduce a fix for this?\n\nBest,\nFabio\n\n---\n\n**rianoc-kx**: The function is defined from within a `.q` script which is why the automated documentation plugin in not finding it.\nhttps://github.com/KxSystems/pykx/blob/main/src/pykx/extensions/gateway.q#L41\nWe'll review if we can tidy this up and have it documented where you would expect.\n\nFor `rtp + hdb`,  yes it is supposed to be a sum.\n\n",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 182,
    "metadata": {
      "issue_number": 55,
      "state": "open",
      "labels": [],
      "comments_count": 2,
      "created_at": "2026-01-06T18:44:03Z",
      "updated_at": "2026-01-27T15:41:59Z",
      "closed_at": null,
      "author": "fabiogaiera",
      "top_comments": [
        "**fabiogaiera**: Hi! Any plans to introduce a fix for this?\n\nBest,\nFabio",
        "**rianoc-kx**: The function is defined from within a `.q` script which is why the automated documentation plugin in not finding it.\nhttps://github.com/KxSystems/pykx/blob/main/src/pykx/extensions/gateway.q#L41\nWe'll review if we can tidy this up and have it documented where you would expect.\n\nFor `rtp + hdb`,  yes it is supposed to be a sum.\n\n"
      ],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-b2728c0fb5ec",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/39",
    "title": "`__setattr__` and `__setitem__` have a different behavior",
    "text": "# `__setattr__` and `__setitem__` have a different behavior\n\nHi, I'm not sure it's a bug, maybe it's by design.\r\n**Describe the bug**\r\n`__setattr__` and `__setitem__` have a different behavior, one sets to global and the other on a namespace.\r\nhttps://github.com/KxSystems/pykx/blob/bf05b31d5fe40c1d033bda4566ca34a777f8d536/src/pykx/__init__.py#L170-L191\r\n\r\n\r\n\r\n**To Reproduce**\r\n```python\r\npykx.q[\"b\"] = 11\r\npykx.q(\"show b\")\r\n# output is 11\r\npykx.q.a = 10\r\npykx.q(\"show .a\")\r\n# output is 10\r\npykx.q(\"show a\")\r\n# QError: a\r\n```\r\n\r\n**Expected behavior**\r\nShouldn't both have same behavior?\r\n\n\n## Top Comments\n\n**rianoc-kx**: `pykx.q.a` falls under the context interface which is designed for use with namespaces\r\nhttps://code.kx.com/pykx/3.0/user-guide/advanced/context_interface.html\r\n \r\nFor assigning q variables `pykx.q[\"a\"] =` is the suggested syntax currently.\r\n\n\n---\n\n**Matoran**: Thanks for the documentation and explanation, all clear. Will update old pyq code to be compatible.",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 121,
    "metadata": {
      "issue_number": 39,
      "state": "closed",
      "labels": [],
      "comments_count": 2,
      "created_at": "2024-11-20T12:17:39Z",
      "updated_at": "2024-11-20T14:33:02Z",
      "closed_at": "2024-11-20T14:33:02Z",
      "author": "Matoran",
      "top_comments": [
        "**rianoc-kx**: `pykx.q.a` falls under the context interface which is designed for use with namespaces\r\nhttps://code.kx.com/pykx/3.0/user-guide/advanced/context_interface.html\r\n \r\nFor assigning q variables `pykx.q[\"a\"] =` is the suggested syntax currently.\r\n",
        "**Matoran**: Thanks for the documentation and explanation, all clear. Will update old pyq code to be compatible."
      ],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-956a0c7d92b3",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/34",
    "title": "Couldn't connect to license daemon",
    "text": "# Couldn't connect to license daemon\n\nHow to use pykx without internet connection?\n\n## Top Comments\n\n**cmccarthy1**: Hi @freeclb \r\n\r\nTo use PyKX without an internet connection you will need access to a commercial version of the software. Currently personal use requires an internet connection assuming you're not requiring just the unlicensed IPC functionality.\r\n\r\nYou can reach out to our sales teams by booking a demo https://kx.com/book-demo/\n\n---\n\n**freeclb**: ok，thanks!",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 69,
    "metadata": {
      "issue_number": 34,
      "state": "closed",
      "labels": [],
      "comments_count": 2,
      "created_at": "2024-08-21T02:57:20Z",
      "updated_at": "2024-08-28T08:30:30Z",
      "closed_at": "2024-08-28T08:30:30Z",
      "author": "freeclb",
      "top_comments": [
        "**cmccarthy1**: Hi @freeclb \r\n\r\nTo use PyKX without an internet connection you will need access to a commercial version of the software. Currently personal use requires an internet connection assuming you're not requiring just the unlicensed IPC functionality.\r\n\r\nYou can reach out to our sales teams by booking a demo https://kx.com/book-demo/",
        "**freeclb**: ok，thanks!"
      ],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-13306878c58d",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/28",
    "title": "Pandas .std() method returns incorrect values in edge cases",
    "text": "# Pandas .std() method returns incorrect values in edge cases\n\n**Describe the bug**\r\nSeveral edge cases cause the .std() method to fail\r\n\r\n\r\n**To Reproduce**\r\nUnzip attachment, run the attached jupyter notebook. \r\n[pykx_std_tests.zip](https://github.com/KxSystems/pykx/files/15315589/pykx_std_tests.zip)\r\n\r\n\r\nNotebook will walk thru each edge case, compare to the expected behavior and provide potential solution\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Windows10\r\n - KDB+ banner information: 4.0 , 2024.03.28\r\n - Repository version: 2.4.0\r\n\n\n## Top Comments\n\n**cmccarthy1**: Hi @jbetz34 thanks for highlighting this, we'll take a look at this and aim to include updates in a patch release\n\n---\n\n**cmccarthy1**: Hi @jbetz34\r\n\r\nToday we released PyKX 2.5.2, this includes fixes for the issues highlighted in your notebook for which we are extremely grateful.\r\n\r\nThanks for raising awareness of these edge-cases.\r\n\r\nConor",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 126,
    "metadata": {
      "issue_number": 28,
      "state": "closed",
      "labels": [],
      "comments_count": 2,
      "created_at": "2024-05-15T02:38:58Z",
      "updated_at": "2024-07-05T12:36:22Z",
      "closed_at": "2024-07-05T12:36:21Z",
      "author": "jbetz34",
      "top_comments": [
        "**cmccarthy1**: Hi @jbetz34 thanks for highlighting this, we'll take a look at this and aim to include updates in a patch release",
        "**cmccarthy1**: Hi @jbetz34\r\n\r\nToday we released PyKX 2.5.2, this includes fixes for the issues highlighted in your notebook for which we are extremely grateful.\r\n\r\nThanks for raising awareness of these edge-cases.\r\n\r\nConor"
      ],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-f111813cd706",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/2",
    "title": "Example of  qsql.select to filter with Python Datetime",
    "text": "# Example of  qsql.select to filter with Python Datetime\n\n**Is your feature request related to a problem? Please describe.**\r\nSo far all the examples for  qsql.select which use the \"where\"  only filter on simple data types like string or integer. I cannot make it work for datetime and unfortunately no examples are provided. Many thanks in advance !\r\n\r\n**Describe the solution you'd like**\r\nA few examples which use qsql.select to filter data on datetime columns using \"where\" parameter.\r\n\r\n**Describe alternatives you've considered**\r\nI have tried a lot of possible way to do this using  qsql.select, but all of them throw an exception.\r\n\r\n\n\n## Top Comments\n\n**rianoc-kx**: \r\n> **Note**\r\n> https://code.kx.com/q/basics/datatypes/#temporal\r\n> The 4-byte datetime datatype (15) is deprecated in favour of the 8-byte timestamp datatype (12).\r\n\r\n\r\nCreate q table with `datetime` column:\r\n\r\n```q\r\n>>> kx.q('t:([] a:.z.z+til 10)')\r\npykx.Identity(pykx.q('::'))\r\n```\r\n\r\n```q\r\n>>> kx.q('t')\r\npykx.Table(pykx.q('\r\na\r\n-----------------------\r\n2023.07.31T10:30:48.609\r\n2023.08.01T10:30:48.609\r\n2023.08.02T10:30:48.609\r\n2023.08.03T10:30:48.609\r\n2023.08.04T10:30:48.609\r\n2023.08.05T10:30:48.609\r\n2023.08.06T10:30:48.609\r\n2023.08.07T10:30:48.609\r\n2023.08.08T10:30:48.609\r\n2023.08.09T10:30:48.609\r\n'))\r\n```\r\n\r\nFilter table:\r\n\r\n```q\r\n>>> pykx.q.qsql.select('t', where='a within (2023.07.31T00:00;2023.08.03T00:00)')\r\npykx.Table(pykx.q('\r\na\r\n-----------------------\r\n2023.07.31T10:30:48.609\r\n2023.08.01T10:30:48.609\r\n2023.08.02T10:30:48.609\r\n'))\r\n```\r\n\n\n---\n\n**Cambyst**: Hi @rianoc-kx , thank you very much for this, very helpful !",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 187,
    "metadata": {
      "issue_number": 2,
      "state": "closed",
      "labels": [],
      "comments_count": 2,
      "created_at": "2023-07-30T07:34:51Z",
      "updated_at": "2023-08-01T08:38:44Z",
      "closed_at": "2023-08-01T08:38:43Z",
      "author": "Cambyst",
      "top_comments": [
        "**rianoc-kx**: \r\n> **Note**\r\n> https://code.kx.com/q/basics/datatypes/#temporal\r\n> The 4-byte datetime datatype (15) is deprecated in favour of the 8-byte timestamp datatype (12).\r\n\r\n\r\nCreate q table with `datetime` column:\r\n\r\n```q\r\n>>> kx.q('t:([] a:.z.z+til 10)')\r\npykx.Identity(pykx.q('::'))\r\n```\r\n\r\n```q\r\n>>> kx.q('t')\r\npykx.Table(pykx.q('\r\na\r\n-----------------------\r\n2023.07.31T10:30:48.609\r\n2023.08.01T10:30:48.609\r\n2023.08.02T10:30:48.609\r\n2023.08.03T10:30:48.609\r\n2023.08.04T10:30:48.609\r\n2023.08.05T10:30:48.609\r\n2023.08.06T10:30:48.609\r\n2023.08.07T10:30:48.609\r\n2023.08.08T10:30:48.609\r\n2023.08.09T10:30:48.609\r\n'))\r\n```\r\n\r\nFilter table:\r\n\r\n```q\r\n>>> pykx.q.qsql.select('t', where='a within (2023.07.31T00:00;2023.08.03T00:00)')\r\npykx.Table(pykx.q('\r\na\r\n-----------------------\r\n2023.07.31T10:30:48.609\r\n2023.08.01T10:30:48.609\r\n2023.08.02T10:30:48.609\r\n'))\r\n```\r\n",
        "**Cambyst**: Hi @rianoc-kx , thank you very much for this, very helpful !"
      ],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-a2acbfe6a56d",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/51",
    "title": "Update to 3.1.5",
    "text": "# Update to 3.1.5\n\nIt appears that the main branch of this repo hasn't been updated since 3.1.3, maybe the gitlab<->github sync is broken?\nWhen time allows, would you be able to update this repo to the latest version (3.1.5 as of writing)?\nAlso appears that 3.1.2 was the last github release, if possible, it would be good to keep this in sync as well.\n\nThanks in advance!",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 68,
    "metadata": {
      "issue_number": 51,
      "state": "closed",
      "labels": [],
      "comments_count": 1,
      "created_at": "2025-10-27T00:30:16Z",
      "updated_at": "2025-12-02T13:13:03Z",
      "closed_at": "2025-12-02T13:13:03Z",
      "author": "jibanes",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-fcf6f4278851",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/50",
    "title": "[mkdocs] pykx.toq is missing, yet referenced in toq.md",
    "text": "# [mkdocs] pykx.toq is missing, yet referenced in toq.md\n\nhttps://github.com/KxSystems/pykx/blob/8806edde49274ea976bd63b43a07f77c561859c5/docs/api/pykx-q-data/toq.md?plain=1#L12\n\npykx.toq doesn't exist, preventing mkdocs to run (unless if this line is removed from toq.md)",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 25,
    "metadata": {
      "issue_number": 50,
      "state": "closed",
      "labels": [],
      "comments_count": 1,
      "created_at": "2025-10-20T05:34:44Z",
      "updated_at": "2025-10-20T13:43:25Z",
      "closed_at": "2025-10-20T13:43:25Z",
      "author": "jibanes",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-8dad4329c25d",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/49",
    "title": "Numpy 2.0 requires np.NaN to be expressed as np.nan",
    "text": "# Numpy 2.0 requires np.NaN to be expressed as np.nan\n\nnumpy 2.0 requires \"np.NaN\" to be expressed as \"np.nan\"\n\nhttps://github.com/KxSystems/pykx/blob/8806edde49274ea976bd63b43a07f77c561859c5/docs/user-guide/advanced/Pandas_API.ipynb#L2925\nhttps://github.com/KxSystems/pykx/blob/8806edde49274ea976bd63b43a07f77c561859c5/docs/user-guide/advanced/Pandas_API.ipynb#L2926\n\nreplacing np.NaN with np.nan in the two lines above resolves this issue and allows mkdocs to run.",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 38,
    "metadata": {
      "issue_number": 49,
      "state": "closed",
      "labels": [],
      "comments_count": 1,
      "created_at": "2025-10-20T05:29:11Z",
      "updated_at": "2025-10-20T13:41:20Z",
      "closed_at": "2025-10-20T13:41:20Z",
      "author": "jibanes",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-720821ee242f",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/43",
    "title": "AttributeError: 'EmbeddedQ' object has no attribute 'ctx' when trying to run simple code",
    "text": "# AttributeError: 'EmbeddedQ' object has no attribute 'ctx' when trying to run simple code\n\n**Describe the bug**\n\n\n```python\nkx.q.til(10)\n```\n\nI got `AttributeError: 'EmbeddedQ' object has no attribute 'ctx'` error when running this line from the tutorial.\n\n\n\n**To Reproduce**\n\n\nI'm on an ARM Mac with 2 `q` installations, 1 installed by manually downloading the binary from kx.com, 1 installed by from conda with `conda install -c kx jupyterq`. First one is located at `/Users/tsca/q/m64/q`, the 2nd is at `/Users/tsca/mamba/envs/fin/bin/q`, and the 2nd is before the 1st one in $PATH. Both binaries run and have the exact same banner message (please see the bottom).\n\n\nI was following the tutorial by setting these env vars:\n```bash\nexport QHOME=$HOME/q\nexport QLIC=$HOME/q\nexport PYKX_UNLICENSED='true'\n# if on mac\nexport PYKX_Q_EXECUTABLE=$QHOME/m64/q\n```\n\nAnd then I ran this simple `test_pykx.py` file:\n```python\n#!/usr/bin/env python3\n\nimport pykx as kx\n\nkx.q.til(10)\n```\n\nAnd I got:\n\n```\nTraceback (most recent call last):\n  File \"/Users/tsca/testdir/q/test_pykx.py\", line 5, in <module>\n    kx.q.til(10)\n    └ <module 'pykx' from '/Users/tsca/mamba/envs/fin/lib/python3.11/site-packages/pykx/__init__.py'>\n  File \"/Users/tsca/mamba/envs/fin/lib/python3.11/site-packages/pykx/__init__.py\", line 140, in __getattr__\n    ctx = self.__getattribute__('ctx')\n    │     └ pykx.q\n    └ <module 'pykx.ctx' from '/Users/tsca/mamba/envs/fin/lib/python3.11/site-packages/pykx/ctx.py'>\nAttributeError: 'EmbeddedQ' object has no attribute 'ctx'\n```\n\nI tried Googling the error message but wasn't able to find similar error reported by other users, except this one (https://learninghub.kx.com/forums/topic/pykxexception-valid-kdb-q-license/), which wasn't helpful.\n\n`debug_environment()` output:\n```\n>>> import pykx as kx\n>>> kx.util.debug_environment()\n**** PyKX information ****\npykx.args: ()\npykx.qhome: /Users/tsca/q\npykx.qlic: /Users/tsca/q\npykx.licensed: False\npykx.__version__: 2.3.0\npykx.file: /Users/tsca/mamba/envs/fin/lib/python3.11/site-packages/pykx/util.py\n**** Python information ****\nsys.version: 3.11.0 | packaged by conda-forge | (main, Jan 14 2023, 12:26:40) [Clang 14.0.6 ]\npandas: 2.2.3\nnumpy: 1.26.4\npytz: 2025.1\nwhich python: /Users/tsca/mamba/envs/fin/bin/python\nwhich python3: /Users/tsca/mamba/envs/fin/bin/python3\n**** Platform information ****\nplatform.platform: macOS-15.3.1-arm64-arm-64bit\n**** PyKX Environment Variables ****\nPYKX_IGNORE_QHOME: \nPYKX_KEEP_LOCAL_TIMES: \nPYKX_ALLOCATOR: \nPYKX_GC: \nPYKX_LOAD_PYARROW_UNSAFE: \nPYKX_MAX_ERROR_LENGTH: \nPYKX_NOQCE: \nPYKX_Q_LIB_LOCATION: \nPYKX_RELEASE_GIL: \nPYKX_Q_LOCK: \nPYKX_DEFAULT_CONVERSION: \nPYKX_SKIP_UNDERQ: \nPYKX_UNSET_GLOBALS: \nPYKX_DEBUG_INSIGHTS_LIBRARIES: \nPYKX_EXECUTABLE: /Users/tsca/mamba/envs/fin/bin/python3\nPYKX_PYTHON_LIB_PATH: \nPYKX_PYTHON_BASE_PATH: \nPYKX_PYTHON_HOME_PATH: \nPYKX_DIR: /Users/tsca/mamba/envs/fin/lib/python3.11/site-packages/pykx\nPYKX_UNLICENSED: true\nPYKX_LICENSED: \nPYKX_BETA_FEATURES: \nPYKX_NO_SIGNAL: \n**** PyKX Deprecated Environment Variables ****\nSKIP_UNDERQ: \nUNSET_PYKX_GLOBALS: \nKEEP_LOCAL_TIMES: \nIGNORE_QHOME: \nUNDER_PYTHON: \nPYKX_NO_SIGINT: \n**** q Environment Variables ****\nQARGS: \nQHOME: /Users/tsca/q\nQLIC: /Users/tsca/q\nQINIT: \n**** License information ****\npykx.qlic directory: True\npykx.qhome writable: True\npykx.qhome lics: ['kc.lic']\npykx.qlic lics: ['kc.lic']\n**** q information ****\nwhich q: /Users/tsca/mamba/envs/fin/bin/q\nq info: \n(`m64;4.1;2025.02.18)\n\"\"\n```\n\n`q` is correctly set up and can run without issue.\n\n\n\n**Desktop (please complete the following information):**\n - OS: macOS 15.3.1 24D70 arm64\n - KDB+ banner information `KDB+ 4.1 2025.02.18 Copyright (C) 1993-2025 Kx Systems\nm64/ 8(24)core 16384MB tsca tsca 127.0.0.1 EXPIRE 2026.03.15 KDB PLUS PERSONAL`\n\n```\n>>> kx.__version__\n'2.3.0'\n```\n\n\n",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 409,
    "metadata": {
      "issue_number": 43,
      "state": "open",
      "labels": [],
      "comments_count": 1,
      "created_at": "2025-03-16T20:15:55Z",
      "updated_at": "2025-03-18T09:44:11Z",
      "closed_at": null,
      "author": "tddschn",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-289ac1c58876",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/14",
    "title": "Addition of skew, add_prefix, add_suffix, count, std functions",
    "text": "# Addition of skew, add_prefix, add_suffix, count, std functions\n\n---\r\nname: Addition of skew, add_prefix, add_suffix, count, std functions\r\nabout: Missing pandas API functionality\r\ntitle: 'Addition of skew, add_prefix, add_suffix, count, std functions'\r\nlabels:  ''\r\nassignees: '@nipsn @marcosvm13 @neutropolis @MiguelGomezC'\r\n\r\n---\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\nNo\r\n\r\n**Describe the solution you'd like**\r\nAn implementation of said functions.\r\n\r\n**Describe alternatives you've considered**\r\n\r\n\r\n**Additional resource**\r\nLinks to pandas documentation of said functions:\r\n\r\n- https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.add_suffix.html\r\n- https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.add_prefix.html#pandas.DataFrame.add_prefix\r\n- https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.skew.html#pandas.DataFrame.skew\r\n- https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.count.html#pandas.DataFrame.count\r\n- https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.std.html#pandas.DataFrame.std\r\n\r\n",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 85,
    "metadata": {
      "issue_number": 14,
      "state": "closed",
      "labels": [],
      "comments_count": 1,
      "created_at": "2023-12-05T08:52:14Z",
      "updated_at": "2024-01-22T14:53:29Z",
      "closed_at": "2024-01-22T14:53:29Z",
      "author": "nipsn",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-dbe37ed40698",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/58",
    "title": "3.1.8",
    "text": "# 3.1.8\n\nCould you please merge the 3.1.8 changes in?",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 10,
    "metadata": {
      "issue_number": 58,
      "state": "open",
      "labels": [],
      "comments_count": 0,
      "created_at": "2026-02-17T23:40:53Z",
      "updated_at": "2026-02-18T23:10:33Z",
      "closed_at": null,
      "author": "jibanes",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-73572b101cd0",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/48",
    "title": "mkdocs.yml's mkdocstrings uses an obsolete method (rendering)",
    "text": "# mkdocs.yml's mkdocstrings uses an obsolete method (rendering)\n\nhttps://github.com/KxSystems/pykx/blob/8806edde49274ea976bd63b43a07f77c561859c5/mkdocs.yml#L99\n\n```\n[...]\n  - mkdocstrings:\n      handlers:\n        python:\n          rendering:              <---- no longer supported\n            docstring_section_style: 'table'\n            heading_level: 2\n            line_length: 80\n            members_order: 'source'\n            merge_init_into_class: true\n[...]\n```\n\nPer https://mkdocstrings.github.io/usage/handlers/?h=rendering#rendering-options : \n\"Since mkdocstrings 0.19, the YAML rendering key is merged into the options key.\"\nNote: 0.19 was released in May 28, 2022.\n\nNaturally, replacing \"rendering:\" with \"options:\" fixes it and allows mkdocs to run using a recent (>2022) version of mkdocstrings.",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 75,
    "metadata": {
      "issue_number": 48,
      "state": "open",
      "labels": [],
      "comments_count": 0,
      "created_at": "2025-10-20T05:24:23Z",
      "updated_at": "2025-10-20T05:31:27Z",
      "closed_at": null,
      "author": "jibanes",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-7e632ebb4b10",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/47",
    "title": "How to use q from streamlit?",
    "text": "# How to use q from streamlit?\n\n**Describe the bug**\n\nI am trying to connect to q from streamlit using the following function:\n\nHowever:\n\n1. The connection works the first time.\n2. The connection just stops working the second time. It blocks on `is_healthy()` call.\n3. It is impossible to kill straemlit. I have to pkill -s 9 -f streamlit every time.\n\n**To Reproduce**\n\nThis is pseudocode:\n\n```\nimport os\nimport pykx as kx\nimport contextlib\nimport streamlit as st\n\n@contextlib.contextmanager\ndef with_qconn():\n    \"\"\"\n    Make connection to q.\n    Check https://code.kx.com/pykx/3.1/user-guide/advanced/streamlit.html\n    \"\"\"\n    port = os.environ.get(\"Q_PORT\")\n    assert port, \"Q_PORT must be set to use q\"\n    print(f\"Connecting to Q on localhost:{port}\")\n    conn = st.connection(\n        \"pykx\",\n        type=kx.streamlit.PyKXConnection,\n        host=\"localhost\",\n        port=int(port),\n    )\n    eprint(\"checking health\")\n    if not conn.is_healthy():\n        print(f\"Resetting connection to Q on localhost:{port}\")\n        conn.reset()\n    else:\n        print(f\"Connected to Q on localhost:{port}\")\n    assert conn.is_healthy()\n    try:\n        yield conn\n    finally:\n        kx.shutdown_thread()\n\ndef query_q():\n  with with_qconn() as qconn:\n      qconn.query(r\"\\l /some/place\", format=\"q\")\n      # ...\n      return qconn.query(\"data\", columns=columns, where=where, format=\"qsql\").pd()\n\nif st.button(\"clickme\"):\n   st.dataframe(query_q())\n```\n\nI am exeucting it something along:\n\n```\n$ export QLIB=/etc/pykx8 Q_PORT=15050 PYKX_BETA_FEATURES=1 PYKX_IGNORE_HOME=1 PYKX_THREADING=1 QHOME=... PYKX_Q_EXECUTABLE=... \n$ ./bin/multirun -v '/opt/sp/qlib/4.0.0.x86_64/q --no-qce --no-kurl --no-objstor --no-qlog --no-sql -p 15050' 'streamlit run --browser.serverAddress=nyzls3291d ./main.py'\nmultirun: launched command /opt/sp/qlib/4.0.0.x86_64/q --no-qce --no-kurl --no-objstor --no-qlog --no-sql -p 15050 with pid 3884235\nmultirun: launched command streamlit run --browser.serverAddress=nyzls3291d ./main.py with pid 3884236\n\n  You can now view your Streamlit app in your browser.\n\n  URL: http://nyzls3291d:8503\n\n\nConnecting to Q on localhost:15050\nchecking health\nConnected to Q on localhost:15050\nConnecting to Q on localhost:15050\nchecking health\n# now it is blocked...\n```\n\n**Expected behavior**\n\nThe connection to q should work on the second time streamlit is opened.\n\nI should be able to kill streamlit normally with just SIGINT. It never exits.\n\n**Screenshots**\n\n**Desktop (please complete the following information):**\n - OS: rockylinux 9\n - KDB+ banner information KDB+ 4.0 2021.04.26 Copyright (C) 1993-2021 Kx Systems l64/ 8(8)core 514509MB cukrowsk nyzls3291d 10.67.3.208 EXPIRE 2055.01.01 squarepoint ops 8 cores #97088\n - Repository version pykx[streamlit]==3.1.4\n\n**Additional context**\n\n\nHow to use pykx in streamlit? How to only kill the thread on exit? Thank you\n",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 340,
    "metadata": {
      "issue_number": 47,
      "state": "open",
      "labels": [],
      "comments_count": 0,
      "created_at": "2025-07-24T15:37:16Z",
      "updated_at": "2025-07-24T15:37:16Z",
      "closed_at": null,
      "author": "Kamilcuk",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-1dd923beca98",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/45",
    "title": "IPC example Discarding unexpected async message from handle",
    "text": "# IPC example Discarding unexpected async message from handle\n\n**Describe the bug**\nHi, the example [readwrite.py](https://github.com/KxSystems/pykx/tree/main/examples/ipc) doesn't work (on licensed mode at least).\n\n**To Reproduce**\nFollow instructions to test it (following readme)\n```\n// run tick.q\n$ q tick/tick.q sym ./log/\nq)\n\n// run the mock feed\n$ q tick/feed.q\nq)\n\n// Start the q process to receive data from PyKX\n$ q -p 5130\nq)\n```\n\n```\n\n```\n\n**Expected behavior**\nA clear and concise description of what you expected to happen.\n\n**Screenshots**\n```python\npython readwrite.py \nRunning example in presence of licensed q\nWARN: Discarding unexpected async message from handle: 11 # not happy about async message\nTraceback (most recent call last):\n  File \"readwrite.py\", line 58, in <module>\n    trade = kx.q('trade')\n  File \"pykx/embedded_q.py\", line 246, in __call__\n    return factory(result, False, name=query.__str__())\n  File \"pykx/_wrappers.pyx\", line 522, in pykx._wrappers._factory\n  File \"pykx/_wrappers.pyx\", line 515, in pykx._wrappers.factory\npykx.exceptions.QError: trade\n```\n\n\n**Additional context**\npykx 3.1.2",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 150,
    "metadata": {
      "issue_number": 45,
      "state": "open",
      "labels": [],
      "comments_count": 0,
      "created_at": "2025-05-09T08:49:48Z",
      "updated_at": "2025-05-09T08:49:48Z",
      "closed_at": null,
      "author": "Matoran",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-dd383a249a46",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/37",
    "title": "%q cell magic",
    "text": "# %q cell magic\n\n**Is your feature request related to a problem? Please describe.**\r\nHi, no problem related. Pyq had the functionality of both cell and line magics which was useful to explore tables.\r\n\r\n**Describe the solution you'd like**\r\nAdding the functionality\r\n\r\n**Describe alternatives you've considered**\r\nI changed locally my `nbextension.py` file to support it.\r\n```python\r\ndef q_line(code):\r\n    return q(\"\", code + \"\\n\")\r\n\r\n\r\ndef load_ipython_extension(ipython):\r\n    ipython.register_magic_function(q, \"cell\")\r\n    ipython.register_magic_function(q_line, \"line\", \"q\")\r\n```\r\nSecond version, more clean but changes `q` function:\r\nif code is `None`, it means line magic. We need to patch code and instructions to execute correctly.\r\n```python\r\ndef q(instructions,code=None):\r\n    if code == None:\r\n        code = instructions + \"\\n\"\r\n        instructions = \"\"\r\n        ...\r\n\r\n\r\ndef load_ipython_extension(ipython):\r\n    ipython.register_magic_function(q, \"both\")\r\n```\r\n\r\n\r\n**Additional resource**\r\nhttps://ipython.readthedocs.io/en/stable/api/generated/IPython.core.interactiveshell.html#IPython.core.interactiveshell.InteractiveShell.register_magic_function\r\nhttps://github.com/KxSystems/pyq/blob/8c31f19e6ee8970d5b4146c5593cb1ed174e1385/src/pyq/magic.py#L47\r\n",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 122,
    "metadata": {
      "issue_number": 37,
      "state": "open",
      "labels": [],
      "comments_count": 0,
      "created_at": "2024-10-17T16:36:52Z",
      "updated_at": "2024-10-17T16:36:52Z",
      "closed_at": null,
      "author": "Matoran",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  },
  {
    "id": "kx-github_issue-deff5290c4e1",
    "origin": "kx",
    "source_type": "github_issue",
    "url": "https://github.com/KxSystems/pykx/issues/18",
    "title": "[Pandas API] Unexpected behaviour for max, min, prod and sum.",
    "text": "# [Pandas API] Unexpected behaviour for max, min, prod and sum.\n\n**Describe the bug**\r\nThe functions `max`, `min`, `prod` and `sum` produce a `length` error when invoked from a keyed table.\r\n\r\n**To Reproduce**\r\n```python\r\n>>> import pykx as kx\r\n>>> t = kx.q('([a:1 2]b:3 4;c:5 6)')\r\n>>> t\r\npykx.KeyedTable(pykx.q('\r\na| b c\r\n-| ---\r\n1| 3 5\r\n2| 4 6\r\n'))\r\n>>> t.max()\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/Users/j/Github/hablapps/pykx/pykx-dev/lib/python3.9/site-packages/pykx/pandas_api/__init__.py\", line 57, in return_va\r\nl\r\n    res = func(*args, **kwargs)\r\n  File \"/Users/j/Github/hablapps/pykx/pykx-dev/lib/python3.9/site-packages/pykx/pandas_api/pandas_meta.py\", line 80, in inner\r\n    return q('{[x; y] y!x}', res, cols)\r\n  File \"/Users/j/Github/hablapps/pykx/pykx-dev/lib/python3.9/site-packages/pykx/embedded_q.py\", line 226, in __call__\r\n    return factory(result, False)\r\n  File \"pykx/_wrappers.pyx\", line 507, in pykx._wrappers._factory\r\n  File \"pykx/_wrappers.pyx\", line 500, in pykx._wrappers.factory\r\npykx.exceptions.QError: length\r\n```\r\n\r\n**Expected behavior**\r\nIn my view, these methods should behave as follows:\r\n```python\r\n>>> import pykx as kx\r\n0 1 2 3 4 5 6 7 8 9\r\n>>> t = kx.q('([a:1 2]b:3 4;c:5 6)')\r\n>>> t\r\npykx.KeyedTable(pykx.q('\r\na| b c\r\n-| ---\r\n1| 3 5\r\n2| 4 6\r\n'))\r\n>>> t.max()\r\npykx.Dictionary(pykx.q('\r\nb| 4\r\nc| 6\r\n'))\r\n```\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: [macOS Sonoma 14.0]\r\n - KDB+ banner information [KDB+ 4.0 2022.05.11 Copyright (C) 1993-2022 Kx Systems]\r\n - Repository version [0.1.dev21+gd28e93a.d20240117]\r\n\r\n**Additional context**\r\nThis problem is originated in the `preparse_computations` function at the Pandas API https://github.com/KxSystems/pykx/blob/main/src/pykx/pandas_api/pandas_meta.py#L52-L70. Indeed, this function filters the keys from the keyed table but returns the original columns. Later, once the `@convert_result` decorator is invoked, it results in a length mismatch, since the number of columns is greater than the number of results. In fact, this problem should also affect `all` and `any` methods from the Pandas API, but I see that they can't be invoked since they are overwritten by the `KeyedTable` class https://github.com/KxSystems/pykx/blob/main/src/pykx/wrappers.py#L3291-L3295.\r\n",
    "scraped_date": "2026-02-22",
    "content_date": null,
    "topics": [],
    "subtopics": [],
    "credibility": "community",
    "sentiment": "neutral",
    "word_count": 293,
    "metadata": {
      "issue_number": 18,
      "state": "closed",
      "labels": [],
      "comments_count": 0,
      "created_at": "2024-01-17T15:01:24Z",
      "updated_at": "2024-01-22T13:10:50Z",
      "closed_at": "2024-01-22T13:10:50Z",
      "author": "neutropolis",
      "top_comments": [],
      "is_feature_request": false,
      "is_bug": false
    }
  }
]